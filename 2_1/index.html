<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<meta name="language" content="en">
<meta name="date" content="2008-03-05T02:35:48-06:00">
<meta name="generator" content="deplate.rb 0.8">
<title>User&rsquo;s Guide for VirtualGL 2.1 and TurboVNC 0.4</title>
<link rel="start" href="index.html" title="Frontpage">
<link rel="chapter" href="index.html#hd001" title="1 Legal Information">
<link rel="chapter" href="index.html#hd002" title="2 Overview">
<link rel="chapter" href="index.html#hd003" title="3 System Requirements">
<link rel="chapter" href="index.html#hd004" title="4 Obtaining and Installing VirtualGL">
<link rel="chapter" href="index.html#hd005" title="5 Obtaining and Installing TurboVNC">
<link rel="chapter" href="index.html#hd006" title="6 Configuring a Linux or Solaris Machine as a VirtualGL Server">
<link rel="chapter" href="index.html#hd007" title="7 Configuring a Windows Machine as a Client for the VGL Image Transport">
<link rel="chapter" href="index.html#hd008" title="8 Using VirtualGL with the VGL Image Transport">
<link rel="chapter" href="index.html#hd009" title="9 Using VirtualGL with TurboVNC">
<link rel="chapter" href="index.html#hd0010" title="10 Using VirtualGL with Other X Proxies">
<link rel="chapter" href="index.html#hd0011" title="11 Using VirtualGL in a Sun Ray Environment">
<link rel="chapter" href="index.html#hd0012" title="12 vglrun and Shell Scripts">
<link rel="chapter" href="index.html#hd0013" title="13 Using VirtualGL with Applications That Manually Load OpenGL">
<link rel="chapter" href="index.html#hd0014" title="14 Using VirtualGL with Chromium and ModViz VGP">
<link rel="chapter" href="index.html#hd0015" title="15 Other Application Recipes">
<link rel="chapter" href="index.html#hd0016" title="16 Advanced OpenGL Features">
<link rel="chapter" href="index.html#hd0017" title="17 Performance Measurement">
<link rel="chapter" href="index.html#hd0018" title="18 The VirtualGL Configuration Dialog">
<link rel="chapter" href="index.html#hd0019" title="19 Advanced Configuration">
<link rel="stylesheet" type="text/css" href="virtualgl.css" title="virtualgl">
</head>
<body >
<a name="#pagetop"></a>
<div class="title">
<p class="title">User&rsquo;s Guide for VirtualGL 2.1 and TurboVNC 0.4</p>
</div>
<a name="file000"></a>
<p><em>Intended audience:</em> System Administrators, Graphics Programmers,
Researchers, and others with knowledge of the Linux or Solaris operating
systems, OpenGL and GLX, and X windows.</p>

<div id="Table_of_Contents">
<div id="Table_of_ContentsBlock" class="toc">
<h1 class="toc">Table of Contents</h1>
<ul class="toc">
    <li class="toc">
        <a href="#hd001" class="toc">1 Legal Information</a>
    </li>
    <li class="toc">
        <a href="#hd002" class="toc">2 Overview</a>
    </li>
    <li class="toc">
        <a href="#hd003" class="toc">3 System Requirements</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd003001" class="toc">3.1 Linux/x86</a>
            </li>
            <li class="toc">
                <a href="#hd003002" class="toc">3.2 Linux/Itanium</a>
            </li>
            <li class="toc">
                <a href="#hd003003" class="toc">3.3 Solaris/x86</a>
            </li>
            <li class="toc">
                <a href="#hd003004" class="toc">3.4 Solaris/Sparc</a>
            </li>
            <li class="toc">
                <a href="#hd003005" class="toc">3.5 Mac/x86</a>
            </li>
            <li class="toc">
                <a href="#hd003006" class="toc">3.6 Windows</a>
            </li>
            <li class="toc">
                <a href="#hd003007" class="toc">3.7 Additional Requirements for Stereographic
                Rendering</a>
            </li>
            <li class="toc">
                <a href="#hd003008" class="toc">3.8 Additional Requirements for Transparent
                Overlays</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd004" class="toc">4 Obtaining and Installing VirtualGL</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd004001" class="toc">4.1 Installing VirtualGL on Linux</a>
            </li>
            <li class="toc">
                <a href="#hd004002" class="toc">4.2 Installing VirtualGL on Solaris</a>
            </li>
            <li class="toc">
                <a href="#hd004003" class="toc">4.3 Installing VirtualGL on Mac (Client
                Only)</a>
            </li>
            <li class="toc">
                <a href="#hd004004" class="toc">4.4 Installing VirtualGL on Windows
                (Client Only)</a>
            </li>
            <li class="toc">
                <a href="#hd004005" class="toc">4.5 Installing VirtualGL from Source</a>
            </li>
            <li class="toc">
                <a href="#hd004006" class="toc">4.6 Obtaining and Installing the Sun
                Ray Plugin</a>
            </li>
            <li class="toc">
                <a href="#hd004007" class="toc">4.7 Uninstalling VirtualGL</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd005" class="toc">5 Obtaining and Installing TurboVNC</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd005001" class="toc">5.1 Installing TurboVNC on Linux</a>
            </li>
            <li class="toc">
                <a href="#hd005002" class="toc">5.2 Installing TurboVNC on Solaris</a>
            </li>
            <li class="toc">
                <a href="#hd005003" class="toc">5.3 Installing TurboVNC on Mac (Client
                Only)</a>
            </li>
            <li class="toc">
                <a href="#hd005004" class="toc">5.4 Installing TurboVNC on Windows
                (Client Only)</a>
            </li>
            <li class="toc">
                <a href="#hd005005" class="toc">5.5 Installing TurboVNC from Source</a>
            </li>
            <li class="toc">
                <a href="#hd005006" class="toc">5.6 Uninstalling TurboVNC</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd006" class="toc">6 Configuring a Linux or Solaris Machine
        as a VirtualGL Server</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd006001" class="toc">6.1 GLP: Using VirtualGL Without an
                X Server</a>
            </li>
            <li class="toc">
                <a href="#hd006002" class="toc">6.2 Granting Access to the Server&rsquo;s
                X Display</a>
            </li>
            <li class="toc">
                <a href="#hd006003" class="toc">6.3 SSh Server Configuration</a>
            </li>
            <li class="toc">
                <a href="#hd006004" class="toc">6.4 Un-Configuring the Server</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd007" class="toc">7 Configuring a Windows Machine as a Client
        for the VGL Image Transport</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd007001" class="toc">7.1 Optimizing Exceed</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd008" class="toc">8 Using VirtualGL with the VGL Image Transport</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd008001" class="toc">8.1 VGL Image Transport with X11 Forwarding</a>
            </li>
            <li class="toc">
                <a href="#hd008002" class="toc">8.2 VGL Image Transport with a Direct
                X11 Connection</a>
            </li>
            <li class="toc">
                <a href="#hd008003" class="toc">8.3 VGL Image Transport with SSL Encryption</a>
            </li>
            <li class="toc">
                <a href="#hd008004" class="toc">8.4 VGL Image Transport with X11 Forwarding
                and SSh Tunneling</a>
            </li>
            <li class="toc">
                <a href="#hd008005" class="toc">8.5 VGL Image Transport over Gigabit
                Networks</a>
            </li>
            <li class="toc">
                <a href="#hd008006" class="toc">8.6 The VirtualGL Client Application:
                Nuts and Bolts</a>
                <ul class="toc">
                    <li class="toc">
                        <a href="#hd008006001" class="toc">8.6.1 The VirtualGL Client and Firewalls</a>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd009" class="toc">9 Using VirtualGL with TurboVNC</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd009001" class="toc">9.1 Using TurboVNC and VirtualGL on
                the Same Server</a>
            </li>
            <li class="toc">
                <a href="#hd009002" class="toc">9.2 Using TurboVNC When VirtualGL Is
                Running on a Different Machine</a>
            </li>
            <li class="toc">
                <a href="#hd009003" class="toc">9.3 Disconnecting and Killing the TurboVNC
                Session</a>
            </li>
            <li class="toc">
                <a href="#hd009004" class="toc">9.4 Using TurboVNC in a Web Browser</a>
            </li>
            <li class="toc">
                <a href="#hd009005" class="toc">9.5 Optimizing TurboVNC&rsquo;s Performance
                for Different Network Types</a>
            </li>
            <li class="toc">
                <a href="#hd009006" class="toc">9.6 Securing a TurboVNC Connection</a>
            </li>
            <li class="toc">
                <a href="#hd009007" class="toc">9.7 Further Reading</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd0010" class="toc">10 Using VirtualGL with Other X Proxies</a>
    </li>
    <li class="toc">
        <a href="#hd0011" class="toc">11 Using VirtualGL in a Sun Ray Environment</a>
    </li>
    <li class="toc">
        <a href="#hd0012" class="toc">12 vglrun and Shell Scripts</a>
    </li>
    <li class="toc">
        <a href="#hd0013" class="toc">13 Using VirtualGL with Applications
        That Manually Load OpenGL</a>
    </li>
    <li class="toc">
        <a href="#hd0014" class="toc">14 Using VirtualGL with Chromium and
        ModViz VGP</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd0014001" class="toc">14.1 Configuration 1: Sort-First Rendering
                (Image-Space Decomposition)</a>
            </li>
            <li class="toc">
                <a href="#hd0014002" class="toc">14.2 Configuration 2: Sort-First Rendering
                (Image-Space Decomposition) with Readback</a>
            </li>
            <li class="toc">
                <a href="#hd0014003" class="toc">14.3 Configuration 3: Sort-Last Rendering
                (Object-Space Decomposition)</a>
            </li>
            <li class="toc">
                <a href="#hd0014004" class="toc">14.4 A Note About Performance</a>
            </li>
            <li class="toc">
                <a href="#hd0014005" class="toc">14.5 ModViz VGP and VirtualGL</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd0015" class="toc">15 Other Application Recipes</a>
    </li>
    <li class="toc">
        <a href="#hd0016" class="toc">16 Advanced OpenGL Features</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd0016001" class="toc">16.1 Stereographic Rendering</a>
                <ul class="toc">
                    <li class="toc">
                        <a href="#hd0016001001" class="toc">16.1.1 Quad-Buffered Stereo</a>
                    </li>
                    <li class="toc">
                        <a href="#hd0016001002" class="toc">16.1.2 Anaglyphic Stereo</a>
                    </li>
                    <li class="toc">
                        <a href="#hd0016001003" class="toc">16.1.3 Selecting a Stereo Mode</a>
                    </li>
                </ul>
            </li>
            <li class="toc">
                <a href="#hd0016002" class="toc">16.2 Transparent Overlays</a>
            </li>
            <li class="toc">
                <a href="#hd0016003" class="toc">16.3 Indexed (PseudoColor) Rendering</a>
            </li>
            <li class="toc">
                <a href="#hd0016004" class="toc">16.4 Troubleshooting</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd0017" class="toc">17 Performance Measurement</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd0017001" class="toc">17.1 VirtualGL&rsquo;s Built-In Profiling
                System</a>
            </li>
            <li class="toc">
                <a href="#hd0017002" class="toc">17.2 Frame Spoiling</a>
            </li>
            <li class="toc">
                <a href="#hd0017003" class="toc">17.3 VirtualGL Diagnostic Tools</a>
            </li>
        </ul>
    </li>
    <li class="toc">
        <a href="#hd0018" class="toc">18 The VirtualGL Configuration Dialog</a>
    </li>
    <li class="toc">
        <a href="#hd0019" class="toc">19 Advanced Configuration</a>
        <ul class="toc">
            <li class="toc">
                <a href="#hd0019001" class="toc">19.1 Server Settings</a>
            </li>
            <li class="toc">
                <a href="#hd0019002" class="toc">19.2 Client Settings</a>
            </li>
        </ul>
    </li>
</ul>
</div></div>
<hr class="break" />


<h1 id="hd001"><a name="file001"></a>1&nbsp;Legal Information</h1>

<p><img src="somerights20.png" alt="somerights20" class="inline" id="imgid_0" name="imgid_0"/></p>

<p>This document and all associated illustrations are licensed under the
<span class="remote"><a href="http://creativecommons.org/licenses/by/2.5/" class="remote">Creative
Commons Attribution 2.5 License</a></span><a name="idx001"></a>.  Any
works which contain material derived from this document must cite The
VirtualGL Project as the source of the material and list the current
URL for the VirtualGL web-site.</p>

<p>This product includes software developed by the
<span class="remote"><a href="http://www.openssl.org" class="remote">OpenSSL
Project</a></span><a name="idx002"></a> for use in the OpenSSL Toolkit.
Further information is contained in
<a href="LICENSE-OpenSSL.txt"><code>LICENSE-OpenSSL.txt</code></a><a name="idx003"></a>,
which can be found in the same directory as this documentation.</p>

<p>VirtualGL includes software developed by the
<span class="remote"><a href="http://www.fltk.org/" class="remote">FLTK
Project</a></span><a name="idx004"></a>.</p>

<p>VirtualGL is licensed under the <a href="LICENSE.txt">wxWindows Library
License, v3</a><a name="idx005"></a>, a derivative of the <a href="LGPL.txt">GNU
Lesser General Public License (LGPL)</a><a name="idx006"></a>.</p>

<hr class="break" />


<h1 id="hd002"><a name="file002"></a>2&nbsp;Overview</h1>

<p><a name="Overview"></a></p>

<p>VirtualGL is an open source package which gives any Unix or Linux remote
display software the ability to run OpenGL applications with full 3D
hardware acceleration.  Some remote display software, such as VNC,
lacks the ability to run OpenGL applications entirely.  Other remote
display software forces OpenGL applications to use a slow software-only
OpenGL renderer, to the detriment of performance as well as compatibility.
And running OpenGL applications using the traditional remote X-Windows
approach causes all of the OpenGL commands and 3D data to be sent over
the network to be rendered on the client machine, which is not a tenable
proposition unless the data is relatively small and static, unless
the network is fast, and unless the OpenGL application is specifically
tuned for a remote X-Windows environment.</p>

<p>With VirtualGL, the OpenGL commands and 3D data are instead redirected
to a 3D graphics accelerator on the server machine, and only the rendered
3D images are sent to the client machine.  VirtualGL thus &ldquo;virtualizes&rdquo;
3D graphics hardware, allowing it to be co-located in the &ldquo;cold
room&rdquo; with compute and storage resources.  VirtualGL also allows
3D graphics hardware to be shared among multiple users, and it provides
real-time performance on even the most modest of networks.  This makes
it possible for large, noisy, hot 3D workstations to be replaced with
laptops or even thinner clients; but more importantly, it eliminates
the workstation and the network as barriers to data size.  Users can
now visualize gigabytes and gigabytes of data in real time without
needing to cache any of the data locally or sit in front of the machine
that is rendering the data.</p>

<p>Normally, a 3D Unix OpenGL application would send all of its drawing
commands and data, both 2D and 3D, to an X-Windows server, which may
be located across the network from the application server.  VirtualGL,
however, employs a technique called &ldquo;split rendering&rdquo; to
force the 3D commands from the application to go to a 3D graphics card
in the application server.  VGL accomplishes this by pre-loading a
dynamic shared object (DSO) into the application at run time.  This
DSO intercepts a handful of GLX, OpenGL, and X11 commands necessary
to perform split rendering.  Whenever a window is created by the application,
VirtualGL creates a corresponding 3D pixel buffer (&ldquo;Pbuffer&rdquo;)
on the server&rsquo;s 3D graphics card.  Whenever the application requests
that an OpenGL rendering context be created on the window, VirtualGL
intercepts the request and creates the context in the Pbuffer instead.
Whenever the application swaps or flushes the drawing buffer to indicate
that it has completed rendering a frame, VirtualGL reads back the Pbuffer
and sends the rendered 3D image to the client.</p>

<p>The beauty of this approach is its non-intrusiveness.  VirtualGL monitors
a few X11 commands and events to determine when windows have been resized,
etc., but it does not interfere in any way with the delivery of 2D
X11 commands to the X server.  For the most part, VGL does not interfere
with the delivery of OpenGL commands to the graphics card, either (there
are some exceptions, such as its handling of color index rendering.)
VGL merely forces the OpenGL commands to be delivered to a server-side
graphics card rather than a client-side one.  Once the OpenGL rendering
context has been established in a server-side Pbuffer, everything (including
esoteric OpenGL extensions, fragment/vertex programs, etc.) should
&ldquo;just work.&rdquo;  In most cases, if an application runs locally
on a 3D server/workstation, that same application will run remotely
from that same server/workstation using VirtualGL.  But obviously,
if it were always as simple as that, we could all turn out the lights
and go home.  Most of the time spent developing VirtualGL has been
spent working around &ldquo;stupid application tricks.&rdquo;</p>

<p>VirtualGL can currently use one of three &ldquo;image transports&rdquo;
to send rendered 3D images to the client machine:</p>

<p><a name="VGL_Image_Transport"></a></p>

<dl class="Description">
    <dt class="Description">1. VGL Image Transport (Formerly &ldquo;Direct Mode&rdquo;)</dt>
    <dd class="Description">
        The VGL image transport is most often used whenever the X server is
        located across the network from the application server, for instance
        if the X server is running on the user&rsquo;s desktop machine.  VirtualGL
        uses its own protocol on a dedicated TCP socket to send the rendered
        3D images to the client machine, and the VirtualGL Client application
        decodes the images and composites them into the appropriate X window.
        The VGL transport can either deliver uncompressed images (RGB encoded),
        or it can compress images in real time using a high-speed JPEG codec.
        It also supports the delivery of stereo image pairs, which can be reconstructed
        into a stereo image by the VirtualGL Client.
    </dd>
</dl>

<a name="fig002001"></a>
<div class="figure">
<p class="caption">Figure 2.1: The VGL Image Transport with a Remote X Server</p>
<img src="vgltransport.png" alt="vgltransport" class="figure" id="imgid_13" name="imgid_13"/>
</div>

<p><a name="X11_Image_Transport"></a></p>

<dl class="Description">
    <dt class="Description">2. X11 Image Transport (Formerly &ldquo;Raw Mode&rdquo;)</dt>
    <dd class="Description">
        The X11 image transport simply draws the rendered 3D images into the
        appropriate X window using XPutImage() and similar X-Windows commands.
        This is most useful in conjunction with an &ldquo;X Proxy&rdquo;, which
        can be one of any number of Unix remote display applications, such
        as VNC.  These X proxies are essentially &ldquo;virtual&rdquo; X servers.
        They appear to the application to be a normal X server, but they perform
        X11 rendering to a virtual framebuffer in main memory	rather than to
        a real framebuffer on a graphics card.  This allows the X proxy to
        send only images to the client machine rather than chatty X-Windows
        rendering commands.  When using the X11 transport, VirtualGL does not
        perform any image compression or encoding itself.  It instead relies
        upon an X proxy to encode and deliver the images to the client(s).
        Since the use of an X proxy eliminates the need to send X-Windows commands
        over the network, this is the best means of using VirtualGL over high-latency
        or low-bandwidth networks. The VirtualGL Project provides an accelerated
        version of VNC, called &ldquo;TurboVNC&rdquo;, which is meant to be
        used with VirtualGL&rsquo;s X11 transport, and the combination of the
        two provides a highly-performant remote 3D	solution, even on slow networks.
        TurboVNC also provides rudimentary collaboration capabilities, allowing
        multiple users to simultaneously interact with the same 3D application.
    </dd>
</dl>

<a name="fig002002"></a>
<div class="figure">
<p class="caption">Figure 2.2: The X11 Image Transport with an X Proxy</p>
<img src="x11transport.png" alt="x11transport" class="figure" id="imgid_14" name="imgid_14"/>
</div>

<dl class="Description">
    <dt class="Description">3. Sun Ray Image Transport</dt>
    <dd class="Description">
        The Sun Ray thin client environment from Sun Microsystems consists
        of an X proxy (the Sun Ray Server Software) and a series of ultra-thin
        hardware clients that connect to this proxy over a network.  It is
        similar in concept to VNC, in that a virtual X server is created for
        every user and that only images, not rendering commands, are sent to
        the client.  But unlike VNC, the client is not a piece of software
        running on a workstation or laptop.  The client is a fanless, diskless
        little box with only a monitor port, USB ports, a network jack, and
        a smart card slot (used for authentication.)<br /> <br /> This environment
        presents unique challenges to VirtualGL, however.  The first challenge
        is that the Sun Ray clients contain relatively slow CPUs, so they are
        not fast enough to decompress JPEG in real time.  The second challenge
        is that Sun Ray servers are generally provisioned to handle a lot of
        simultaneous users, so using VirtualGL&rsquo;s X11 transport would
        put undue stress on both the Sun Ray servers and the network on which
        they reside. Thus, Sun Microsystems designed a plugin for VirtualGL
        which allows VGL to compress images using a protocol that can be sent
        directly to the Sun Ray hardware client without having to pass through
        the Sun Ray server first. Since the plugin uses the proprietary Sun
        Ray image compression technology, it is currently closed source, but
        the binary packages can be downloaded for free as part of Sun&rsquo;s
        Shared Visualization product, which also includes VirtualGL, TurboVNC,
        and other goodies.
    </dd>
</dl>

<a name="fig002003"></a>
<div class="figure">
<p class="caption">Figure 2.3: The Sun Ray Image Transport</p>
<img src="sunray.png" alt="sunray" class="figure" id="imgid_15" name="imgid_15"/>
</div>

<hr class="break" />


<h1 id="hd003"><a name="file003"></a>3&nbsp;System Requirements</h1>


<h2 id="hd003001">3.1&nbsp;Linux/x86</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server (x86)</th>
    <th class="head standard">Server (x86-64)</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Pentium 4, 1.7 GHz or faster (or equivalent) <ul class="Itemize"><li>
    For optimal performance, the processor should support SSE2 extensions.
</li>
<li>
    Dual processors recommended
</li></ul></td>
    <td class="standard">Pentium 4/Xeon with EM64T, or&hellip;<br /> AMD Opteron or Athlon64, 1.8 GHz or faster <ul class="Itemize"><li>
    For optimal performance with 64-bit VirtualGL, the processor should
    support SSE3 extensions.  Only newer AMD 64-bit processors (mid-2005
    and later) support SSE3.
</li>
<li>
    Dual processors recommended
</li></ul></td>
    <td class="standard">Pentium III or Pentium 4, 1.0 GHz or faster (or equivalent)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard" colspan="2">Any decent 3D graphics card that supports Pbuffers <ul class="Itemize"><li>
    Install the vendor drivers for the server&rsquo;s 3D graphics card.
    Do not use the drivers that ship with Linux, as these do not provide
    3D acceleration or Pbuffer support.
</li></ul></td>
    <td class="standard">Any graphics card with decent 2D performance <ul class="Itemize"><li>
    If using a 3D graphics card, install the vendor drivers for that 3D
    graphics card.
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Recommended O/S</td>
    <td class="standard" colspan="3"><ul class="Itemize"><li>
    Any distribution in the
    <span class="remote"><a href="http://www.redhat.com/" class="remote">RedHat</a></span><a name="idx007"></a>
    or
    <span class="remote"><a href="http://www.novell.com/linux/" class="remote">SuSE</a></span><a name="idx008"></a>
    families (including
    <span class="remote"><a href="http://fedora.redhat.com/" class="remote">Fedora</a></span><a name="idx009"></a>,
    <span class="remote"><a href="http://www.centos.org/" class="remote">CentOS</a></span><a name="idx0010"></a>,
    and <span class="remote"><a href="http://www.whiteboxlinux.org/" class="remote">White
    Box</a></span><a name="idx0011"></a>)
</li>
<li>
    Specifically tested with RedHat Enterprise Linux 2.1, RedHat/CentOS
    Enterprise Linux 3, 4, &amp; 5 (32-bit and 64-bit), and SuSE Linux
    Enterprise 9 &amp; 10 (32-bit and 64-bit)
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard" colspan="3">X server configured to export True Color (24-bit or 32-bit) visuals</td>
  </tr>
</table>
</div>



<h2 id="hd003002">3.2&nbsp;Linux/Itanium</h2>

<p>VirtualGL should build and run on Itanium Linux, but it has not been
thoroughly tested. 
<span class="remote"><a href="http://sourceforge.net/users/dcommander" class="remote">Contact
us</a></span><a name="idx0012"></a> if you encounter any difficulties.</p>


<h2 id="hd003003">3.3&nbsp;Solaris/x86</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Pentium 4/Xeon with EM64T, or&hellip;<br /> AMD Opteron or Athlon64, 1.8 GHz or faster <ul class="Itemize"><li>
    Dual processors recommended
</li></ul></td>
    <td class="standard">Pentium III or Pentium 4, 1.0 GHz or faster (or equivalent)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard">nVidia 3D graphics card</td>
    <td class="standard">Any graphics card with decent 2D performance</td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard" colspan="3">Solaris 10 or higher</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li>
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun
    mediaLib</a></span><a name="idx0013"></a> (v2.5 or higher recommended
    *)
</li>
<li>
    <span class="remote"><a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage" class="remote">Solaris
    Patch</a></span><a name="idx0014"></a> 118345-04 (or later)
</li>
<li>
    X server configured to export True Color (24-bit or 32-bit) visuals
</li></ul></td>
    <td class="standard"><ul class="Itemize"><li>
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun
    mediaLib</a></span><a name="idx0015"></a> (v2.5 or higher recommended
    *)
</li>
<li>
    X server configured to export True Color (24-bit or 32-bit) visuals
</li></ul></td>
  </tr>
</table>
</div>


<div class="important"><p class="important">
* mediaLib is pre-installed on Solaris 10/x86 and higher, but it is strongly recommended that you download and install the mediaLib 2.5 upgrade from the link above.  mediaLib 2.5 improves the performance of VirtualGL significantly on Solaris/x86 systems, when compared to the pre-installed version of mediaLib.
</p></div>


<h2 id="hd003004">3.4&nbsp;Solaris/Sparc</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">UltraSPARC III 900 MHz or faster <ul class="Itemize"><li>
    Dual processors recommended
</li></ul></td>
    <td class="standard">UltraSPARC III 900 MHz or faster</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard">Any decent 3D graphics card that supports Pbuffers <ul class="Itemize"><li>
    Tested with
    <span class="remote"><a href="http://www.sun.com/desktop/products/graphics/xvr600/" class="remote">XVR-600</a></span><a name="idx0016"></a>,
    <span class="remote"><a href="http://www.sun.com/desktop/products/graphics/xvr1200/" class="remote">XVR-1200</a></span><a name="idx0017"></a>
    (&ldquo;jfb&rdquo;), and
    <span class="remote"><a href="http://www.sun.com/desktop/products/graphics/xvr2500/" class="remote">XVR-2500</a></span><a name="idx0018"></a>
    (&ldquo;kfb&rdquo;)
</li></ul></td>
    <td class="standard">Any graphics card with decent 2D performance</td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard" colspan="2">Solaris 8 or higher</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li>
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun
    mediaLib</a></span><a name="idx0019"></a> (pre-installed on Solaris
    10 and higher)
</li>
<li>
    <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun
    OpenGL</a></span><a name="idx0020"></a> 1.3 or later (1.5 or later
    required for <a href="#GLP_Usage">GLP</a><a name="idx0021"></a>)
</li>
<li>
    If your system does not ship with SSh pre-installed (older Solaris
    8 and 9 systems don&rsquo;t), then download and install an OpenSSH
    package from
    <span class="remote"><a href="http://www.blastwave.org/" class="remote">Blastwave</a></span><a name="idx0022"></a>
    or <a href="http://www.sunfreeware.com/.">http://www.sunfreeware.com/.</a>
</li>
<li>
    X server configured to export True Color (24-bit or 32-bit) visuals
    (if not using <a href="#GLP_Usage">GLP</a><a name="idx0023"></a>)
</li></ul> Recommended <span class="remote"><a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage" class="remote">Patches</a></span><a name="idx0024"></a> <ul class="Itemize"><li>
    <em>OpenGL 1.5</em>: 120812-15 (or later)
</li>
<li>
    <em>XVR-2500 driver</em>: 120928-15 (or later)
</li>
<li>
    <em>OpenGL 1.3, 32-bit:</em> 113886-41 (or later)
</li>
<li>
    <em>OpenGL 1.3, 64-bit:</em> 113887-41 (or later)
</li></ul></td>
    <td class="standard"><ul class="Itemize"><li>
    <span class="remote"><a href="http://www.sun.com/processors/vis/mlib.html" class="remote">Sun
    mediaLib</a></span><a name="idx0025"></a> (pre-installed on Solaris
    10 and higher)
</li>
<li>
    <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun
    OpenGL</a></span><a name="idx0026"></a> 1.3 or later recommended if
    the client has a 3D graphics card installed.  If available, the VirtualGL
    Client will use OpenGL to draw images, which improves the client&rsquo;s
    performance on Sun 3D graphics cards.
</li>
<li>
    If your system does not ship with SSh pre-installed (older Solaris
    8 and 9 systems don&rsquo;t), then download and install an OpenSSH
    package from
    <span class="remote"><a href="http://www.blastwave.org/" class="remote">Blastwave</a></span><a name="idx0027"></a>
    or <a href="http://www.sunfreeware.com/.">http://www.sunfreeware.com/.</a>
</li>
<li>
    X server configured to export True Color (24-bit or 32-bit) visuals
</li></ul></td>
  </tr>
</table>
</div>



<h2 id="hd003005">3.5&nbsp;Mac/x86</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Any Intel-based Mac</td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard">OS X 10.4 (&ldquo;Tiger&rdquo;) or later</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li>
    <em>VGL Image Transport Only</em>: Mac X11 application (in the &ldquo;Optional
    Installs&rdquo; package on the OS X install discs)
</li></ul></td>
  </tr>
</table>
</div>



<h2 id="hd003006">3.6&nbsp;Windows</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Pentium III or Pentium 4, 1.0 GHz or faster (or equivalent)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard">Any graphics card with decent 2D performance</td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard">Windows 2000 or later</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li>
    <em>VGL Image Transport Only</em>:
    <span class="remote"><a href="http://connectivity.hummingbird.com" class="remote">Hummingbird</a></span><a name="idx0028"></a>
    Exceed 8 or newer required
</li>
<li>
    Client display must have a 24-bit or 32-bit color depth (True Color.)
</li></ul></td>
  </tr>
</table>
</div>



<h2 id="hd003007">3.7&nbsp;Additional Requirements for Stereographic Rendering</h2>

<div class="important"><p class="important">
The client requirements do not apply to anaglyphic stereo.  See Chapter <a href="#Advanced_OpenGL" class="ref">16</a> for more details.
</p></div>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Linux</td>
    <td class="standard" colspan="2" rowspan="3">3D graphics card that supports stereo (example: nVidia Quadro) and is configured to export stereo visuals</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Solaris/x86</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Mac/x86</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Solaris/Sparc</td>
    <td class="standard"><ul class="Itemize"><li>
    <span class="remote"><a href="http://www.sun.com/desktop/products/graphics/xvr2500/" class="remote">XVR-2500</a></span><a name="idx0029"></a>
    graphics card
</li>
<li>
    <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun
    OpenGL</a></span><a name="idx0030"></a> 1.5 or later
</li>
<li>
    OpenGL
    <span class="remote"><a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage" class="remote">Patch</a></span><a name="idx0031"></a>
    120812-14 (or later)
</li>
<li>
    XVR-2500 driver
    <span class="remote"><a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage" class="remote">Patch</a></span><a name="idx0032"></a>
    120928-10 (or later)
</li></ul></td>
    <td class="standard"><ul class="Itemize"><li>
    3D graphics card that supports stereo (examples: XVR-1200, XVR-2500)
    and is configured to export stereo visuals
</li>
<li>
    <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun
    OpenGL</a></span><a name="idx0033"></a> 1.3 or later
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Windows</td>
    <td class="standard">N/A</td>
    <td class="standard"><ul class="Itemize"><li>
    3D graphics card that supports stereo (examples: nVidia Quadro, 3D
    Labs Wildcat Realizm) and is configured to export stereo pixel formats
</li>
<li>
    <span class="remote"><a href="http://connectivity.hummingbird.com" class="remote">Hummingbird</a></span><a name="idx0034"></a>
    Exceed 3D v8 or newer
</li></ul></td>
  </tr>
</table>
</div>



<h2 id="hd003008">3.8&nbsp;Additional Requirements for Transparent Overlays</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Linux</td>
    <td class="standard" rowspan="3">3D graphics card that supports transparent overlays (example: nVidia Quadro) and is configured to export overlay visuals</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Solaris/x86</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Mac/x86</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Solaris/Sparc</td>
    <td class="standard"><ul class="Itemize"><li>
    3D graphics card that supports transparent overlays (examples: XVR-1200,
    XVR-2500) and is configured to export overlay visuals
</li>
<li>
    <span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun
    OpenGL</a></span><a name="idx0035"></a> 1.3 or later
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Windows</td>
    <td class="standard"><ul class="Itemize"><li>
    3D graphics card that supports transparent overlays (examples: nVidia
    Quadro, 3D Labs Wildcat Realizm) and is configured to export overlay
    pixel formats
</li>
<li>
    <span class="remote"><a href="http://connectivity.hummingbird.com" class="remote">Hummingbird</a></span><a name="idx0036"></a>
    Exceed 3D v8 or newer
</li></ul></td>
  </tr>
</table>
</div>


<hr class="break" />


<h1 id="hd004"><a name="file004"></a>4&nbsp;Obtaining and Installing VirtualGL</h1>

<div class="important"><p class="important">
VirtualGL must be installed on any machine that will act as a VirtualGL server or as a client for the <a href="#VGL_Image_Transport">VirtualGL Image Transport</a><a name="idx0037"></a>. It is not necessary to install VirtualGL on the client machine if using VNC or another type of X proxy.
</p></div>


<h2 id="hd004001">4.1&nbsp;Installing VirtualGL on Linux</h2>


<h3 id="hd004001001">Installing TurboJPEG</h3>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Download v1.10 or later of the TurboJPEG RPM package (<code>turbojpeg-</code><em><code>{version}</code></em><code>.i386.rpm</code>
        for 32-bit systems or <code>turbojpeg-</code><em><code>{version}</code></em><code>.x86_64.rpm</code>
        for 64-bit systems) from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0038"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0039"></a>. <br />
        <div class="important"><p class="important">
        The 64-bit RPM provides both 32-bit and 64-bit TurboJPEG libraries. <br /><br /> .tgz packages are provided for users of non-RPM-based Linux distributions.  You can use <span class="remote"><a href="http://www.kitenet.net/programs/alien/" class="remote">alien</a></span><a name="idx0040"></a> to convert these into .deb packages if you prefer.
        </p></div>
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the RPM package,
        and issue the following command:
<pre class="verbatim">
rpm&nbsp;-U&nbsp;turbojpeg*.rpm
</pre>

    </li>
</ol>


<h3 id="hd004001002">Installing VirtualGL</h3>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Download the VirtualGL RPM package (<code>VirtualGL-</code><em><code>{version}</code></em><code>.i386.rpm</code>
        for 32-bit systems or <code>VirtualGL-</code><em><code>{version}</code></em><code>.x86_64.rpm</code>
        for 64-bit systems) from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0041"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0042"></a>. <br />
        <div class="important"><p class="important">
        The 64-bit RPM provides both 32-bit and 64-bit VirtualGL components.
        </p></div>
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the RPM package,
        and issue the following commands:
<pre class="verbatim">
rpm&nbsp;-e&nbsp;VirtualGL
rpm&nbsp;-i&nbsp;VirtualGL*.rpm
</pre>

    </li>
</ol>


<h2 id="hd004002">4.2&nbsp;Installing VirtualGL on Solaris</h2>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Download the VirtualGL Solaris package (<code>SUNWvgl-</code><em><code>{version}</code></em><code>.pkg.bz2</code>
        for Sparc or <code>SUNWvgl-</code><em><code>{version}</code></em><code>-x86.pkg.bz2</code>
        for x86) from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0043"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0044"></a>. <br />
        <div class="important"><p class="important">
        Both packages provide both 32-bit and 64-bit VirtualGL components.
        </p></div>
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the package,
        and issue the following commands:
<pre class="verbatim">
pkgrm&nbsp;SUNWvgl
</pre>

        (answer &ldquo;Y&rdquo; when prompted.)
<pre class="verbatim">
bzip2&nbsp;-d&nbsp;SUNWvgl-{version}.pkg.bz2
pkgadd&nbsp;-d&nbsp;SUNWvgl-{version}.pkg
</pre>

        Select the <code>SUNWvgl</code> package (usually option 1) from the
        menu.
    </li>
</ol>
<div class="important"><p class="important">
VirtualGL for Solaris installs into <code>/opt/SUNWvgl</code>.
</p></div>


<h2 id="hd004003">4.3&nbsp;Installing VirtualGL on Mac (Client Only)</h2>

<ol class="Ordered numeric">
    <li class="Ordered">
        Download the VirtualGL Mac disk image (<code>VirtualGL-</code><em><code>{version}</code></em><code>.dmg</code>)
        from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0045"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0046"></a>.
    </li>
    <li class="Ordered">
        Open the disk image, then open <code>VirtualGL-</code><em><code>{version}</code></em><code>.pkg</code>
        inside the disk image.  Follow the instructions to install the Mac
        client.  The Mac package installs files in the same locations as the
        Linux RPM.
    </li>
</ol>


<h2 id="hd004004">4.4&nbsp;Installing VirtualGL on Windows (Client Only)</h2>

<ol class="Ordered numeric">
    <li class="Ordered">
        Download the VirtualGL Windows installer package (<code>VirtualGL-</code><em><code>{version}</code></em><code>.exe</code>)
        from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0047"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0048"></a>.
    </li>
    <li class="Ordered">
        Run the VirtualGL installer.  The installation of VirtualGL should
        be self-explanatory.  The only configuration option is the directory
        into which you want the files to be installed.
    </li>
</ol>


<h2 id="hd004005">4.5&nbsp;Installing VirtualGL from Source</h2>

<p>If you are using a non-RPM-based distribution of Linux or another platform
for which there is not a pre-built VirtualGL binary package available,
then log in as root, download the VirtualGL source tarball (<code>VirtualGL-</code><em><code>{version}</code></em><code>.tar.gz</code>)
from the
<span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
area</a></span><a name="idx0049"></a> of the
<span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
SourceForge web-site</a></span><a name="idx0050"></a>, uncompress it,
<code>cd&nbsp;vgl</code>, and read the contents of <code>BUILDING.txt</code>
for further instructions on how to build and install VirtualGL from
source.</p>


<h2 id="hd004006">4.6&nbsp;Obtaining and Installing the Sun Ray Plugin</h2>

<p>The VirtualGL Sun Ray plugin is a proprietary add-on developed by Sun
Microsystems to integrate VirtualGL with the Sun Ray thin client environment.
If you plan to use this functionality, then it is recommended that
you download and install the
<span class="remote"><a href="http://www.sun.com/servers/cr/visualization/get_it.jsp" class="remote">Sun
Shared Visualization</a></span><a name="idx0051"></a> software.  This
software package is available as a free download (Sun charges for support),
and it includes VirtualGL, TurboVNC, the proprietary Sun Ray plugin,
enhanced documentation, and enhancements to N1 GridEngine to allow
it to manage VirtualGL jobs across a cluster of 3D servers.</p>


<h2 id="hd004007">4.7&nbsp;Uninstalling VirtualGL</h2>


<h3 id="hd004007001">Linux</h3>

<p>As root, issue the following command:</p>

<pre class="verbatim">
rpm&nbsp;-e&nbsp;VirtualGL
</pre>


<h3 id="hd004007002">Solaris</h3>

<p>As root, issue the following command:</p>

<pre class="verbatim">
pkgrm&nbsp;SUNWvgl
</pre>

<p>Answer &ldquo;yes&rdquo; when prompted.</p>


<h3 id="hd004007003">Mac</h3>

<ul class="Itemize">
    <li class="Itemize asterisk">
        Download and install the latest version of
        <span class="remote"><a href="http://www.osxgnu.org/software/pkgdetail.html?project_id=244" class="remote">OSXPM</a></span><a name="idx0052"></a>
    </li>
    <li class="Itemize asterisk">
        Launch OSXPM
    </li>
    <li class="Itemize asterisk">
        Click the &ldquo;Delete Package&rdquo; button
    </li>
    <li class="Itemize asterisk">
        Find <code>VirtualGL-</code><em><code>{version}</code></em><code>.pkg</code>
        in the list of packages and highlight it
    </li>
    <li class="Itemize asterisk">
        Click &ldquo;Delete Selected&rdquo;
    </li>
    <li class="Itemize asterisk">
        Enter your password if prompted
    </li>
    <li class="Itemize asterisk">
        Complain to Apple about the lack of a built-in package uninstaller
        for OS X
    </li>
</ul>


<h3 id="hd004007004">Windows</h3>

<p>Use the &ldquo;Add or Remove Programs&rdquo; applet in the Control
Panel (or the &ldquo;Programs and Features&rdquo; applet if you&rsquo;re
running Vista.)</p>

<hr class="break" />


<h1 id="hd005"><a name="file005"></a>5&nbsp;Obtaining and Installing TurboVNC</h1>

<div class="important"><p class="important">
TurboVNC must be installed on any machine that will act as a TurboVNC server or client.  It is not necessary to install TurboVNC to use the <a href="#VGL_Image_Transport">VirtualGL Image Transport</a><a name="idx0053"></a>.  Also, TurboVNC need not necessarily be installed on the same server as VirtualGL.
</p></div>


<h2 id="hd005001">5.1&nbsp;Installing TurboVNC on Linux</h2>


<h3 id="hd005001001">Installing TurboJPEG</h3>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Download v1.10 or later of the TurboJPEG RPM package (<code>turbojpeg-</code><em><code>{version}</code></em><code>.i386.rpm</code>
        for 32-bit systems or <code>turbojpeg-</code><em><code>{version}</code></em><code>.x86_64.rpm</code>
        for 64-bit systems) from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0054"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0055"></a>. <br />
        <div class="important"><p class="important">
        The 64-bit RPM provides both 32-bit and 64-bit TurboJPEG libraries. <br /><br /> .tgz packages are provided for users of non-RPM-based Linux distributions.  You can use <span class="remote"><a href="http://www.kitenet.net/programs/alien/" class="remote">alien</a></span><a name="idx0056"></a> to convert these into .deb packages if you prefer.
        </p></div>
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the RPM package,
        and issue the following command:
<pre class="verbatim">
rpm&nbsp;-U&nbsp;turbojpeg*.rpm
</pre>

    </li>
</ol>


<h3 id="hd005001002">Installing TurboVNC</h3>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Download the TurboVNC RPM package (<code>turbovnc-</code><em><code>{version}</code></em><code>.i386.rpm</code>)
        from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0057"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0058"></a>. <br />
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the RPM package,
        and issue the following command:
<pre class="verbatim">
rpm&nbsp;-U&nbsp;turbovnc*.rpm
</pre>

    </li>
</ol>


<h2 id="hd005002">5.2&nbsp;Installing TurboVNC on Solaris</h2>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Download the TurboVNC Solaris package (<code>SUNWtvnc-</code><em><code>{version}</code></em><code>.pkg.bz2</code>
        for Sparc or <code>SUNWtvnc-</code><em><code>{version}</code></em><code>-x86.pkg.bz2</code>
        for x86) from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0059"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0060"></a>. <br />
    </li>
    <li class="Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the package,
        and issue the following commands:
<pre class="verbatim">
pkgrm&nbsp;SUNWvgl
</pre>

        (answer &ldquo;Y&rdquo; when prompted.)
<pre class="verbatim">
bzip2&nbsp;-d&nbsp;SUNWtvnc-{version}.pkg.bz2
pkgadd&nbsp;-d&nbsp;SUNWtvnc-{version}.pkg
</pre>

        Select the <code>SUNWtvnc</code> package (usually option 1) from the
        menu.
    </li>
</ol>
<div class="important"><p class="important">
TurboVNC for Solaris installs into <code>/opt/SUNWtvnc</code>.
</p></div>


<h2 id="hd005003">5.3&nbsp;Installing TurboVNC on Mac (Client Only)</h2>

<ol class="Ordered numeric">
    <li class="Ordered">
        Download the TurboVNC Mac disk image (<code>TurboVNC-</code><em><code>{version}</code></em><code>.dmg</code>)
        from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0061"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0062"></a>.
    </li>
    <li class="Ordered">
        Open the disk image, then open <code>TurboVNC-</code><em><code>{version}</code></em><code>.pkg</code>
        inside the disk image.  Follow the instructions to install the Mac
        client.  The Mac package installs files in the same locations as the
        Linux RPM.
    </li>
</ol>


<h2 id="hd005004">5.4&nbsp;Installing TurboVNC on Windows (Client Only)</h2>

<ol class="Ordered numeric">
    <li class="Ordered">
        Download the TurboVNC Windows installer package (<code>TurboVNC-</code><em><code>{version}</code></em><code>.exe</code>)
        from the
        <span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
        area</a></span><a name="idx0063"></a> of the
        <span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
        SourceForge web-site</a></span><a name="idx0064"></a>.
    </li>
    <li class="Ordered">
        Run the TurboVNC installer.  The installation of TurboVNC should be
        self-explanatory.  The only configuration option is the directory into
        which you want the files to be installed.
    </li>
</ol>


<h2 id="hd005005">5.5&nbsp;Installing TurboVNC from Source</h2>

<p>If you are using a non-RPM-based distribution of Linux or another platform
for which there is not a pre-built TurboVNC binary package available,
then log in as root, download the TurboVNC source tarball (<code>turbovnc-</code><em><code>{version}</code></em><code>.tar.gz</code>)
from the
<span class="remote"><a href="http://sourceforge.net/project/showfiles.php?group_id=117509" class="remote">files
area</a></span><a name="idx0065"></a> of the
<span class="remote"><a href="http://sourceforge.net/projects/virtualgl" class="remote">VirtualGL
SourceForge web-site</a></span><a name="idx0066"></a>, uncompress it,
<code>cd&nbsp;vnc/vnc_unixsrc</code>, and read the contents of <code>BUILDING.txt</code>
for further instructions on how to build and install TurboVNC from
source.</p>


<h2 id="hd005006">5.6&nbsp;Uninstalling TurboVNC</h2>


<h3 id="hd005006001">Linux</h3>

<p>As root, issue the following command:</p>

<pre class="verbatim">
rpm&nbsp;-e&nbsp;turbovnc
</pre>


<h3 id="hd005006002">Solaris</h3>

<p>As root, issue the following command:</p>

<pre class="verbatim">
pkgrm&nbsp;SUNWtvnc
</pre>

<p>Answer &ldquo;yes&rdquo; when prompted.</p>


<h3 id="hd005006003">Mac</h3>

<ul class="Itemize">
    <li class="Itemize asterisk">
        Download and install the latest version of
        <span class="remote"><a href="http://www.osxgnu.org/software/pkgdetail.html?project_id=244" class="remote">OSXPM</a></span><a name="idx0067"></a>
    </li>
    <li class="Itemize asterisk">
        Launch OSXPM
    </li>
    <li class="Itemize asterisk">
        Click the &ldquo;Delete Package&rdquo; button
    </li>
    <li class="Itemize asterisk">
        Find <code>TurboVNC-</code><em><code>{version}</code></em><code>.pkg</code>
        in the list of packages and highlight it
    </li>
    <li class="Itemize asterisk">
        Click &ldquo;Delete Selected&rdquo;
    </li>
    <li class="Itemize asterisk">
        Enter your password if prompted
    </li>
    <li class="Itemize asterisk">
        Complain to Apple about the lack of a built-in package uninstaller
        for OS X
    </li>
</ul>


<h3 id="hd005006004">Windows</h3>

<p>Use the &ldquo;Add or Remove Programs&rdquo; applet in the Control
Panel (or the &ldquo;Programs and Features&rdquo; applet if you&rsquo;re
running Vista.)</p>

<hr class="break" />


<h1 id="hd006"><a name="file006"></a>6&nbsp;Configuring a Linux or Solaris Machine as a VirtualGL Server</h1>


<h2 id="hd006001">6.1&nbsp;GLP: Using VirtualGL Without an X Server</h2>

<p><a name="GLP_Usage"></a></p>

<p>Sun&rsquo;s OpenGL library for Solaris/Sparc systems has a special
extension called &ldquo;GLP&rdquo; which allows VirtualGL to directly
access a 3D graphics card even if there is no X server running on the
card.  GLP greatly improves the overall security of the VirtualGL server,
since it eliminates the need to grant X server access to VirtualGL
users.  In addition, GLP makes it easy to assign VirtualGL jobs to
any graphics card in a multi-card system.</p>

<p>When using GLP, the architecture of VirtualGL changes as follows:</p>

<a name="fig006001"></a>
<div class="figure">
<p class="caption">Figure 6.1: The VGL Image Transport with a Remote X Server and GLP</p>
<img src="vgltransportglp.png" alt="vgltransportglp" class="figure" id="imgid_16" name="imgid_16"/>
</div>

<a name="fig006002"></a>
<div class="figure">
<p class="caption">Figure 6.2: The X11 Image Transport with an X Proxy and GLP</p>
<img src="x11transportglp.png" alt="x11transportglp" class="figure" id="imgid_17" name="imgid_17"/>
</div>

<p>If your system is running
<span class="remote"><a href="http://www.sun.com/software/graphics/opengl/" class="remote">Sun
OpenGL</a></span><a name="idx0068"></a> 1.5 for Solaris/Sparc, it is
recommended that you configure it to use GLP:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Log in as root.
    </li>
    <li class="Ordered">
        Run
<pre class="verbatim">
/opt/VirtualGL/bin/vglserver_config
</pre>

    </li>
    <li class="Ordered">
        Select option 3 (<code>Configure&nbsp;server&nbsp;for&nbsp;use&nbsp;with&nbsp;VirtualGL&nbsp;in&nbsp;GLP&nbsp;mode</code>.)
    </li>
    <li class="Ordered">

<pre class="verbatim">
Restrict&nbsp;framebuffer&nbsp;device&nbsp;access&nbsp;to&nbsp;vglusers&nbsp;group&nbsp;(recommended)?
[Y/n]
</pre>

        <dl class="Description">
            <dt class="Description">Yes</dt>
            <dd class="Description">
                Only users in the <code>vglusers</code> group can run OpenGL applications
                on the VirtualGL server (the configuration script will create the <code>vglusers</code>
                group if it doesn&rsquo;t already exist.)  This limits the possibility
                that an unauthorized user could snoop the 3D framebuffer device(s)
                and thus see (or alter) the 3D output of an application running in
                VirtualGL.
            </dd>
            <dt class="Description">No</dt>
            <dd class="Description">
                Any authenticated user can run OpenGL applications on the VirtualGL
                server.  If it is necessary for users outside of the <code>vglusers</code>
                group to log in locally to the server and run OpenGL applications,
                then this is probably the best option.
            </dd>
        </dl>
    </li>
    <li class="Ordered">
        If you chose to restrict framebuffer device access to the <code>vglusers</code>
        group, then edit <code>/etc/group</code> and add <code>root</code>
        to the <code>vglusers</code> group.  If you choose, you can also add
        additional users to the group at this time.  Note that any user you
        add to <code>vglusers</code>	must log out and back in again before
        their new group permissions take effect.
    </li>
    <li class="Ordered">
        Edit the <code>/etc/dt/config/GraphicsDevices</code> file as necessary.
        This file contains a list of paths to 3D framebuffer devices (such
        as <code>/dev/fbs/kfb0</code>, <code>/dev/fbs/jfb0</code>, etc.) that
        you wish to use with VirtualGL.
    </li>
</ol>


<h3 id="hd006001001">Sanity Check</h3>

<p>To verify that the system is ready to run VirtualGL, log out of the
server, log back into the server using SSh, and execute the following
command in the SSh session:</p>

<pre class="verbatim">
/opt/VirtualGL/bin/glxinfo&nbsp;-d&nbsp;glp
</pre>

<p>This command should output a list of visuals and complete with no errors.</p>


<h3 id="hd006001002">Using GLP by Default in VirtualGL</h3>

<p>If you wish VirtualGL to use GLP by default, then you can add</p>

<pre class="verbatim">
VGL_DISPLAY=glp
export&nbsp;VGL_DISPLAY
</pre>

<p>to <code>/etc/profile</code>.  This will cause VirtualGL to use the
first device specified in <code>/etc/dt/config/GraphicsDevices</code>
as the default rendering device.  Users can override this default by
setting <code>VGL_DISPLAY</code> in one of their startup scripts (such
as <code>~/.profile</code> or <code>~/.login</code>) or by passing
an argument of <code>-d&nbsp;&lt;device&gt;</code> to <code>vglrun</code>
when invoking VirtualGL.  See Chapter
<a href="#Advanced_Configuration" class="ref">19</a> for more details.</p>


<h2 id="hd006002">6.2&nbsp;Granting Access to the Server&rsquo;s X Display</h2>

<div class="important"><p class="important">
If you plan to use VirtualGL only with <a href="#GLP_Usage">GLP</a><a name="idx0069"></a>, then you can skip this section.
</p></div>

<p>VirtualGL requires access to the server&rsquo;s 3D graphics card so
that it can create off-screen pixel buffers (Pbuffers) and redirect
the 3D rendering from applications into these Pbuffers.  Unfortunately,
accessing a 3D graphics card on Linux and Solaris/x86 systems or on
Solaris/Sparc systems without <a href="#GLP_Usage">GLP</a><a name="idx0070"></a>
requires going through an X server.  On such systems, the only way
to share the server&rsquo;s 3D graphics card among multiple users is
to grant those users access to the X server that is running on the
3D graphics card.</p>

<p>It is important to understand the security risks associated with this.
Once X display access is granted to a user, there is nothing that would
prevent that user from logging keystrokes or reading back images from
the X display. Using <code>xauth</code>, one can obtain &ldquo;untrusted&rdquo;
X authentication keys which prevent such exploits, but unfortunately,
those untrusted keys also disallow access to the 3D hardware.  So it
is necessary to grant full trusted X access to any users that will
need to run VirtualGL.  Unless you fully trust the users to whom you
are granting this access, you should avoid logging in locally to the
server&rsquo;s X display as root unless absolutely necessary.</p>

<p>This section will explain how to configure a VirtualGL server such
that selected users can run VirtualGL, even if the server is sitting
at the login prompt.</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Shut down the display manager:
        <dl class="Description">
            <dt class="Description">Linux servers</dt>
            <dd class="Description">
<pre class="verbatim">
init&nbsp;3
</pre>

            </dd>
            <dt class="Description">Solaris 10 (and later) servers running GDM</dt>
            <dd class="Description">
<pre class="verbatim">
svcadm&nbsp;disable&nbsp;gdm2-login
</pre>

            </dd>
            <dt class="Description">Solaris servers running dtlogin</dt>
            <dd class="Description">
<pre class="verbatim">
/etc/init.d/dtlogin&nbsp;stop
</pre>

            </dd>
        </dl>
    </li>
    <li class="Ordered">
        Log in as root from the text console (or remotely using SSh.)
    </li>
    <li class="Ordered">
        Run
<pre class="verbatim">
/opt/VirtualGL/bin/vglserver_config
</pre>

    </li>
    <li class="Ordered">
        Select option 1 (<code>Configure&nbsp;server&nbsp;for&nbsp;use&nbsp;with&nbsp;VirtualGL&nbsp;in&nbsp;GLX&nbsp;mode</code>.)
    </li>
    <li class="Ordered">

<pre class="verbatim">
Restrict&nbsp;local&nbsp;X&nbsp;server&nbsp;access&nbsp;to&nbsp;vglusers&nbsp;group&nbsp;(recommended)?
[Y/n]
</pre>

        <dl class="Description">
            <dt class="Description">Yes</dt>
            <dd class="Description">
                Only users in the <code>vglusers</code> group can use VirtualGL (the
                configuration script will create the <code>vglusers</code> group if
                it doesn&rsquo;t already exist.)  This is the most secure option, since
                it prevents any users outside of the <code>vglusers</code> group from
                accessing (and thus exploiting) the VirtualGL server&rsquo;s X display.
            </dd>
            <dt class="Description">No</dt>
            <dd class="Description">
                VirtualGL can be used by any user that successfully logs into the VirtualGL
                server.  The X server can also be accessed (and potentially exploited)
                by any user who is logged into the VirtualGL server.  If you choose
                this option, it is recommended that you also disable the XTEST extension
                (see below.)
            </dd>
        </dl>
    </li>
    <li class="Ordered">

<pre class="verbatim">
Restrict&nbsp;framebuffer&nbsp;device&nbsp;access&nbsp;to&nbsp;vglusers&nbsp;group&nbsp;(recommended)?
[Y/n]
</pre>

        <dl class="Description">
            <dt class="Description">Yes</dt>
            <dd class="Description">
                Only users in the <code>vglusers</code> group can run OpenGL applications
                on the VirtualGL server (the configuration script will create the <code>vglusers</code>
                group if it doesn&rsquo;t already exist.)  This limits the possibility
                that an unauthorized user could snoop the 3D framebuffer device(s)
                and thus see (or alter) the 3D output of an application running in
                VirtualGL.
            </dd>
            <dt class="Description">No</dt>
            <dd class="Description">
                Any authenticated user can run OpenGL applications on the VirtualGL
                server.  If it is necessary for users outside of the <code>vglusers</code>
                group to log in locally to the server and run OpenGL applications,
                then this is probably the best option.
            </dd>
        </dl>
    </li>
    <li class="Ordered">

<pre class="verbatim">
Disable&nbsp;XTEST&nbsp;extension&nbsp;(recommended)?
[Y/n]
</pre>

        <dl class="Description">
            <dt class="Description">Yes</dt>
            <dd class="Description">
                Disabling XTEST will not prevent a user from logging keystrokes or
                reading images from the X display, but if a user has access to the
                X display, disabling XTEST will prevent them from inserting keystrokes
                or mouse events and thus hijacking local X sessions on that display.
            </dd>
            <dt class="Description">No</dt>
            <dd class="Description">
                VNC requires XTEST, so if you need to attach a VNC server to the VirtualGL
                server&rsquo;s local X display, then it is necessary to answer &ldquo;No&rdquo;
                (and thus leave XTEST enabled.)
            </dd>
        </dl>
    </li>
    <li class="Ordered">
        If you chose to restrict X server or framebuffer device access to the
        <code>vglusers</code> group, then edit <code>/etc/group</code> and
        add <code>root</code> to the <code>vglusers</code> group.  If you choose,
        you can also add additional users to the group at this time.  Note
        that any user you add to <code>vglusers</code>	must log out and back
        in again before their new group permissions take effect.
    </li>
    <li class="Ordered">
        Restart the display manager:
        <dl class="Description">
            <dt class="Description">Linux servers</dt>
            <dd class="Description">
<pre class="verbatim">
init&nbsp;5
</pre>

            </dd>
            <dt class="Description">Solaris 10 (and later) servers running GDM</dt>
            <dd class="Description">
<pre class="verbatim">
svcadm&nbsp;enable&nbsp;gdm2-login
</pre>

            </dd>
            <dt class="Description">Solaris servers running dtlogin</dt>
            <dd class="Description">
<pre class="verbatim">
/etc/init.d/dtlogin&nbsp;start
</pre>

            </dd>
        </dl>
    </li>
</ol>


<h3 id="hd006002001">Sanity Check</h3>

<p>To verify that the system is ready to run VirtualGL, log out of the
server, log back into the server using SSh, and execute the following
commands in the SSh session:</p>

<dl class="Description">
    <dt class="Description">If you restricted X server access to <code>vglusers</code></dt>
    <dd class="Description">
<pre class="verbatim">
xauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key
xdpyinfo&nbsp;-display&nbsp;:0
/opt/VirtualGL/bin/glxinfo&nbsp;-display&nbsp;:0
</pre>

        <div class="important"><p class="important">
        NOTE: <code>xauth</code> and <code>xdpyinfo</code> are in <code>/usr/openwin/bin</code> on Solaris systems.
        </p></div>
    </dd>
    <dt class="Description">If you did not restrict X server access</dt>
    <dd class="Description">
<pre class="verbatim">
xdpyinfo&nbsp;-display&nbsp;:0
/opt/VirtualGL/bin/glxinfo&nbsp;-display&nbsp;:0
</pre>

    </dd>
</dl>

<p>Both commands should output a list of visuals and complete with no
errors. If you chose to disable the XTEST extension, then check the
output of <code>xdpyinfo</code> to verify that <code>XTEST</code> does
not show up in the list of extensions.</p>


<h2 id="hd006003">6.3&nbsp;SSh Server Configuration</h2>

<p>The server&rsquo;s SSh daemon should have the <code>X11Forwarding</code>
option enabled and the <code>UseLogin</code> option disabled.  This
is configured in <code>sshd_config</code>, the location of which varies
depending on your distribution of SSh.  Linux and Solaris 10 systems
generally keep this in <code>/etc/ssh</code>, whereas Blastwave OpenSSh
keeps it in <code>/opt/csw/etc</code> and SunFreeware OpenSSh keeps
it in <code>/usr/local/etc</code>.</p>


<h2 id="hd006004">6.4&nbsp;Un-Configuring the Server</h2>

<p>You can use the <code>vglserver_config</code> script to restore the
security settings that were in place before VirtualGL was installed.
Option 2 (<code>Unconfigure&nbsp;server&nbsp;for&nbsp;use&nbsp;with&nbsp;VirtualGL&nbsp;in&nbsp;GLX&nbsp;mode</code>)
will remove any shared access to the server&rsquo;s X display and thus
prevent VirtualGL from accessing the 3D hardware in that manner.  Option
2 will also re-enable the XTEST extension on the server&rsquo;s X display.
Both Option 2 and Option 4 (<code>Unconfigure&nbsp;server&nbsp;for&nbsp;use&nbsp;with&nbsp;VirtualGL&nbsp;in&nbsp;GLP&nbsp;mode</code>)
will restore the framebuffer device permissions to their default (by
default, only root or the user that is currently logged into the system
locally can access the framebuffer devices.)</p>

<div class="important"><p class="important">
NOTE: Unconfiguring the server does not remove the <code>vglusers</code> group or the <code>/etc/dt/config/GraphicsDevices</code> file.
</p></div>

<p>After selecting Option 2, you must restart the display manager before
the changes will take effect.</p>

<hr class="break" />


<h1 id="hd007"><a name="file007"></a>7&nbsp;Configuring a Windows Machine as a Client for the VGL Image Transport</h1>

<ol class="Ordered numeric">
    <li class="Ordered">
        Install Hummingbird Exceed if it isn&rsquo;t already installed.
    </li>
    <li class="Ordered">
        Add the Exceed path (example: <code>C:\Program&nbsp;Files\Hummingbird\Connectivity\9.00\Exceed</code>)
        to the system <code>PATH</code> environment if it isn&rsquo;t already
        there.
    </li>
</ol>


<h2 id="hd007001">7.1&nbsp;Optimizing Exceed</h2>


<h3 id="hd007001001">Disabling Pixel Format Conversion (Exceed 2006 and earlier)</h3>

<ol class="Ordered numeric">
    <li class="Ordered">
        Load Exceed XConfig (right-click on the Exceed taskbar icon, then select
        <em>Tools&ndash;&gt;Configuration</em>.)
    </li>
    <li class="Ordered">
        Open the &ldquo;X Server Protocol&rdquo; applet in XConfig.
        <div class="important"><p class="important">
        If you are using the &ldquo;Classic View&rdquo; mode of XConfig, open the &ldquo;Protocol&rdquo; applet instead.
        </p></div>
    </li>
    <li class="Ordered">
        In the &ldquo;X Server Protocol&rdquo; applet, select the &ldquo;Protocol&rdquo;
        tab and make sure that &ldquo;Use 32 bits per pixel for true color&rdquo;
        is not checked. <br /><br />
        <img src="exceed1.png" alt="exceed1" class="inline" id="imgid_1" name="imgid_1"/>
    </li>
    <li class="Ordered">
        Click &ldquo;Validate and Apply Changes.&rdquo;  If XConfig asks whether
        you want to perform a server reset, click &ldquo;Yes.&rdquo;
    </li>
</ol>


<h3 id="hd007001002">Disabling Backing Store</h3>

<ol class="Ordered numeric">
    <li class="Ordered">
        Load Exceed XConfig (right-click on the Exceed taskbar icon, then select
        <em>Tools&ndash;&gt;Configuration</em>.)
    </li>
    <li class="Ordered">
        Open the &ldquo;Other Server Settings&rdquo; applet in XConfig.
        <div class="important"><p class="important">
        If you are using the &ldquo;Classic View&rdquo; mode of XConfig, open the &ldquo;Performance&rdquo; applet instead.
        </p></div>
    </li>
    <li class="Ordered">
        Select the &ldquo;Performance&rdquo; tab and make sure that &ldquo;Default
        Backing Store&rdquo; is set to &ldquo;None.&rdquo; <br /><br />
        <img src="exceed3.png" alt="exceed3" class="inline" id="imgid_2" name="imgid_2"/>
    </li>
    <li class="Ordered">
        Click &ldquo;Validate and Apply Changes.&rdquo;  If XConfig asks whether
        you want to perform a server reset, click &ldquo;Yes.&rdquo;
    </li>
</ol>


<h3 id="hd007001003">Enabling MIT-SHM</h3>

<p>VirtualGL has the ability to take advantage of the MIT-SHM extension
in Hummingbird Exceed to accelerate image drawing on Windows.  This
can improve the overall performance of the VirtualGL pipeline by as
much as 20% in some cases.</p>

<p>The bad news is that this extension is not consistently implemented
across all versions of Exceed.  In particular, Exceed 8, Exceed 9,
and Exceed 2008 require patches to make it work properly.  If you are
using one of these versions of Exceed, you will need to obtain the
following patches from the Hummingbird support site:</p>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">Product</th>
    <th class="head standard">Patches Required</th>
    <th class="head standard">How to Obtain</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard">Hummingbird Exceed 8.0</td>
    <td class="standard"><code>hclshm.dll</code> v9.0.0.1 (or higher)<br /> <code>xlib.dll</code> v9.0.0.3 (or higher)<br /> <code>exceed.exe</code> v8.0.0.28 (or higher)</td>
    <td class="standard">Download all patches from the <span class="remote"><a href="http://connectivity.hummingbird.com/support/nc/exceed_patches.html" class="remote">Hummingbird support site</a></span><a name="idx0071"></a>. <br /> (<em>Hummingbird WebSupport account required</em>)</td>
  </tr>
  <tr class="standard">
    <td class="standard">Hummingbird Exceed 9.0</td>
    <td class="standard"><code>hclshm.dll</code> v9.0.0.1 (or higher)<br /> <code>xlib.dll</code> v9.0.0.3 (or higher)<br /> <code>exceed.exe</code> v9.0.0.9 (or higher)</td>
    <td class="standard"><code>exceed.exe</code> can be patched by running Hummingbird Update.<br /> <br /> All other patches must be downloaded from the <span class="remote"><a href="http://connectivity.hummingbird.com/support/nc/exceed_patches.html" class="remote">Hummingbird support site</a></span><a name="idx0072"></a>. <br /> (<em>Hummingbird WebSupport account required</em>)</td>
  </tr>
  <tr class="standard">
    <td class="standard">Hummingbird Exceed 2008</td>
    <td class="standard"><code>xlib.dll</code> v13.0.1.235 (or higher)</td>
    <td class="standard">Download all patches from the <span class="remote"><a href="http://connectivity.hummingbird.com/support/nc/exceed_patches.html" class="remote">Hummingbird support site</a></span><a name="idx0073"></a>. <br /> (<em>Hummingbird WebSupport account required</em>)</td>
  </tr>
</table>
</div>


<p>No patches should be necessary for Exceed 10, 2006, or 2007.</p>

<p>Next, you need to enable the MIT-SHM extension in Exceed:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Load Exceed XConfig (right-click on the Exceed taskbar icon, then select
        <em>Tools&ndash;&gt;Configuration</em>.)
    </li>
    <li class="Ordered">
        Open the &ldquo;X Server Protocol&rdquo; applet in XConfig.
        <div class="important"><p class="important">
        If you are using the &ldquo;Classic View&rdquo; mode of XConfig, open the &ldquo;Protocol&rdquo; applet instead.
        </p></div>
    </li>
    <li class="Ordered">
        Select the &ldquo;Extensions&rdquo; tab and make sure that &ldquo;MIT-SHM&rdquo;
        is checked. <br /><br />
        <img src="exceed2.png" alt="exceed2" class="inline" id="imgid_3" name="imgid_3"/>
    </li>
    <li class="Ordered">
        Click &ldquo;Validate and Apply Changes.&rdquo;  If XConfig asks whether
        you want to perform a server reset, click &ldquo;Yes.&rdquo;
        <hr class="break" />
    </li>
</ol>


<h1 id="hd008"><a name="file008"></a>8&nbsp;Using VirtualGL with the VGL Image Transport</h1>

<p><a name="VGL_Image_Transport_Usage"></a></p>


<h3 id="hd008000001">Advantages of the VGL Image Transport</h3>

<ul class="Itemize">
    <li class="Itemize asterisk">
        Seamless windows; every application window appears as a separate window
        on the user&rsquo;s desktop
    </li>
    <li class="Itemize asterisk">
        Supports stereographic and overlay rendering
    </li>
    <li class="Itemize asterisk">
        Built-in encryption
    </li>
    <li class="Itemize asterisk">
        Consumes fewer server resources, since the 2D (X11) rendering occurs
        on the client
    </li>
</ul>


<h3 id="hd008000002">Disadvantages of the VGL Image Transport</h3>

<ul class="Itemize">
    <li class="Itemize asterisk">
        The VGL Image Transport is designed to be used with remote X servers,
        thus it relies on the chatty remote X11 protocol to send the 2D elements
        of the application&rsquo;s GUI to the user&rsquo;s desktop.  As a result,
        the VGL Image Transport is not recommended for use on high-latency
        networks
    </li>
    <li class="Itemize asterisk">
        No collaboration features
    </li>
    <li class="Itemize asterisk">
        Requires purchasing Exceed for use with Windows clients
    </li>
    <li class="Itemize asterisk">
        The client is not stateless.  As with any remote X11 app, if the network
        connection drops, then the application will exit
    </li>
</ul>


<h2 id="hd008001">8.1&nbsp;VGL Image Transport with X11 Forwarding</h2>

<p><a name="X11_Forwarding"></a></p>

<p>This mode is recommended for use on secure local-area networks.  The
X11 traffic is encrypted, but the VirtualGL image stream is left unencrypted
to maximize performance.</p>


<h3 id="hd008001001">Procedure for Linux/Solaris/Mac Clients</h3>

<ol class="Ordered numeric">
    <li class="Ordered">
        Start the X server if it isn&rsquo;t started already (<em>Mac clients:</em>
        start the Mac X11 application.)
    </li>
    <li class="Ordered">
        Open a new terminal window (<em>Mac clients:</em> in the X11 application,
        start a new xterm [Command-N] if one isn&rsquo;t already started.)
    </li>
    <li class="Ordered">
        In the same terminal/xterm window, open a Secure Shell (SSh) session
        into the VirtualGL server:
<pre class="verbatim">
/opt/VirtualGL/bin/vglconnect&nbsp;{user}@{server}
</pre>

        Replace <em><code>{user}</code></em> with your user account name on
        the VirtualGL server and <em><code>{server}</code></em> with the hostname
        or IP address of that server.
    </li>
    <li class="Ordered">
        In the SSh session, start a 3D application using VirtualGL:
<pre class="verbatim">
/opt/VirtualGL/bin/vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        Consult Chapter <a href="#Advanced_Configuration" class="ref">19</a>
        for more information on <code>vglrun</code> command line options.
    </li>
</ol>


<h3 id="hd008001002">Procedure for Windows Clients</h3>

<ol class="Ordered numeric">
    <li class="Ordered">
        Start Exceed if it isn&rsquo;t already started.  Hover the mouse pointer
        over the Exceed taskbar icon and make a note of the display number
        on which Exceed is listening (<em>Example:</em> &ldquo;Exceed 0.0 Multiwindow
        Mode&rdquo;.)
    </li>
    <li class="Ordered">
        Open a new Command Prompt.
    </li>
    <li class="Ordered">
        In the same Command Prompt window, set the <code>DISPLAY</code> environment
        variable to match the display on which Exceed is listening.  Example:
<pre class="verbatim">
set&nbsp;DISPLAY=:0.0
</pre>

        <div class="important"><p class="important">
        If you only ever plan to use one Exceed session at a time, then you can set the <code>DISPLAY</code> environment variable in your global user environment (<em>Control Panel&ndash;&gt;System&ndash;&gt;Advanced&ndash;&gt;Environment Variables</em>.)
        </p></div>
    </li>
    <li class="Ordered">
        Open a Secure Shell (SSh) session into the VirtualGL server:
<pre class="verbatim">
cd&nbsp;/d&nbsp;&quot;c:\program&nbsp;files\virtualgl-{version}-{build}&quot;
vglconnect&nbsp;{user}@{server}
</pre>

        Replace <em><code>{user}</code></em> with your user account name on
        the VirtualGL server and <em><code>{server}</code></em> with the hostname
        or IP address of that server.
    </li>
    <li class="Ordered">
        In the SSh session, start a 3D application using VirtualGL:
<pre class="verbatim">
/opt/VirtualGL/bin/vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        Consult Chapter <a href="#Advanced_Configuration" class="ref">19</a>
        for more information on <code>vglrun</code> command line options.
    </li>
</ol>


<h2 id="hd008002">8.2&nbsp;VGL Image Transport with a Direct X11 Connection</h2>

<p><a name="Direct_X11_Connection"></a></p>

<p>As with the <a href="#X11_Forwarding">previous mode</a><a name="idx0074"></a>,
this mode performs optimally on local-area networks.  However, it is
less secure, since both the X11 traffic and the VGL image stream are
unencrypted.  This mode is primarily useful in grid environments where
you may not know ahead of time which server will execute a VirtualGL
job.  It is assumed that the &ldquo;submit host&rdquo; (the machine
into which you connect with SSh) and the &ldquo;execute hosts&rdquo;
(the machines that will run VirtualGL jobs) share the same home directories
and reside in the same domain.</p>

<div class="important"><p class="important">
Some newer Linux and Solaris distributions ship with default settings that do not allow TCP connections into the X server.  Such systems cannot be used as clients with this procedure unless they are reconfigured to allow X11 TCP connections.
</p></div>


<h3 id="hd008002001">Procedure</h3>

<p>The procedure for this mode is identical to the procedure for <a href="#X11_Forwarding">X11
forwarding</a><a name="idx0075"></a>, except that you should pass a
<code>-x</code> argument to <code>vglconnect</code> when connecting
to the server:</p>

<pre class="verbatim">
/opt/VirtualGL/bin/vglconnect&nbsp;-x&nbsp;{user}@{server}
</pre>


<h2 id="hd008003">8.3&nbsp;VGL Image Transport with SSL Encryption</h2>

<p><a name="SSL_Encryption"></a></p>

<p>This mode encrypts the VGL image stream and, when used in conjunction
with <a href="#X11_Forwarding">X11 forwarding</a><a name="idx0076"></a>,
provides a completely secure solution. However, enabling SSL encryption
can reduce VirtualGL&rsquo;s performance by as much as 20% on high-speed
networks such as Ethernet.</p>


<h3 id="hd008003001">Procedure</h3>

<p>The procedure for this mode is identical to the procedure for <a href="#X11_Forwarding">X11
forwarding</a><a name="idx0077"></a>, except that you should pass an
argument of <code>+s</code> to <code>vglrun</code> when starting a
3D application using VirtualGL.  You can also set the environment variable
<code>VGL_SSL</code> to <code>1</code> on the VirtualGL server prior
to invoking <code>vglrun</code>.  (see Chapter
<a href="#Advanced_Configuration" class="ref">19</a> for more details.)</p>


<h2 id="hd008004">8.4&nbsp;VGL Image Transport with X11 Forwarding and SSh Tunneling</h2>

<p><a name="SSh_Tunneling"></a></p>

<p>This mode is useful when either the VirtualGL server or the client
machine are behind restrictive firewalls and only SSh connections are
allowed through. Both the VGL image stream and the X11 traffic are
tunneled through the SSh connection, and thus this mode provides a
completely secure solution.  However, using SSh tunneling can reduce
VirtualGL&rsquo;s performance by anywhere from 20-40% on high-speed
networks such as Ethernet.</p>


<h3 id="hd008004001">Procedure</h3>

<p>The procedure for this mode is identical to the procedure for <a href="#X11_Forwarding">X11
forwarding</a><a name="idx0078"></a>, except that you should pass a
<code>-s</code> argument to <code>vglconnect</code> when connecting
to the server:</p>

<pre class="verbatim">
/opt/VirtualGL/bin/vglconnect&nbsp;-s&nbsp;{user}@{server}
</pre>

<p><code>vglconnect</code> will make two SSh connections into the server,
the first to find an open port on the server and the second to create
the secure image tunnels and open the secure shell.  If you are not
using an SSh agent to create password-less logins, then this mode will
require you to enter your password twice.</p>

<p><code>vglconnect&nbsp;-s</code> can be used to create multi-layered
SSh tunnels.  For instance, if the VirtualGL server is not directly
accessible from the Internet, you can use <code>vglconnect&nbsp;-s</code>
to connect to a gateway server, then use <code>vglconnect&nbsp;-s</code>
again on the gateway server to connect to the VirtualGL server.  Both
the X11 and the VGL image traffic will be forwarded from the VirtualGL
server through the gateway and to the client.</p>

<div class="figure">
<img src="sshtunnel.png" alt="sshtunnel" class="figure" id="imgid_18" name="imgid_18"/>
</div>


<h2 id="hd008005">8.5&nbsp;VGL Image Transport over Gigabit Networks</h2>

<p>When using the VGL image transport over Gigabit Ethernet or faster
networks, it may be desirable to disable image compression.  This can
be accomplished by passing an argument of <code>-c&nbsp;rgb</code>
to <code>vglrun</code> or setting the environment variable <code>VGL_COMPRESS</code>
to <code>rgb</code> on the VirtualGL server machine. Disabling image
compression will reduce VirtualGL&rsquo;s server and client CPU usage
by 50% or more, but the tradeoff is that it will also increase VirtualGL&rsquo;s
network usage by a factor of 10 or more.  Thus, disabling image compression
is not recommended unless you are using switched Gigabit Ethernet (or
faster) infrastructure and have plenty of bandwidth to spare.</p>


<h2 id="hd008006">8.6&nbsp;The VirtualGL Client Application: Nuts and Bolts</h2>

<p>The VirtualGL Client application receives encoded and/or compressed
images on a dedicated TCP socket, decodes and/or decompresses the images,
and draws the images into the appropriate X window.  In previous versions
of VirtualGL, it was necessary to manually start the VirtualGL Client
prior to connecting to the server, but the new <code>vglconnect</code>
script wraps both <code>vglclient</code> and SSh to greatly simplify
the process of creating VGL Image Transport connections.  One consequence
of this ease of use is that the actual workings of <code>vglclient</code>
are hidden from view, which makes it a bit more difficult to see the
cause of connection failures and other issues as they happen.</p>

<p><code>vglconnect</code> invokes <code>vglclient</code> with an argument
of <code>-detach</code>, which causes <code>vglclient</code> to completely
detach from the console and run as a background daemon.  It will remain
running silently in the background, accepting VGL Image Transport connections
for the X display on which it was started, until the X server is reset
or until the <code>vglclient</code> process is explicitly killed. 
Logging out of the X server will reset the X server and thus kill all
<code>vglclient</code> instances that are attached to it.  You can
also explicitly kill all instances of <code>vglclient</code> running
under your user account by invoking</p>

<pre class="verbatim">
vglclient&nbsp;-kill
</pre>

<p>(<code>vglclient</code> is in <code>/opt/VirtualGL/bin</code> on Linux/Mac/Solaris
systems and in <code>c:\program&nbsp;files\virtualgl-{version}-{build}</code>
on Windows systems.)</p>

<p><code>vglconnect</code> instructs <code>vglclient</code> to redirect
all of its console output to a log file named <em><code>{home}</code></em><code>/.vgl/vglconnect-</code><em><code>{hostname}</code></em><code>-</code><em><code>{display}</code></em><code>.log</code>,
where <em><code>{home}</code></em> is the path of the current user&rsquo;s
home directory (<code>%USERPROFILE%</code> on Windows systems), <em><code>{hostname}</code></em>
is the name of the computer running <code>vglconnect</code>, and <em><code>{display}</code></em>
is the name of the current X display (read from the <code>DISPLAY</code>
environment or passed to <code>vglconnect</code> using the <code>-display</code>
argument.)  In the event that something goes wrong, this log file is
the first place to check.</p>

<p>When <code>vglclient</code> successfully starts on a given X display,
it stores its listener port numbers in a pair of root window properties
on the X display.  If other <code>vglclient</code> instances attempt
to start on the same X display, they read the X window properties,
determine that another <code>vglclient</code> instance is already running,
and exit to allow the first instance to retain control. <code>vglclient</code>
will clean up these X properties under most circumstances, even if
it is explicitly killed.  But under rare circumstances (if sent a SIGKILL
signal on Unix, for instance), a <code>vglclient</code> instance may
exit uncleanly and leave the X properties set.  In these cases, it
may be necessary to add an argument of <code>-force</code> to <code>vglconnect</code>
the next time you use it.  This tells <code>vglconnect</code> to start
a new <code>vglclient</code> instance, regardless of whether <code>vglclient</code>
thinks that there is already an instance running on this X display.
Alternately, you can simply reset your X server to clear the orphaned
X window properties.</p>


<h3 id="hd008006001">8.6.1&nbsp;The VirtualGL Client and Firewalls</h3>

<p>To retain compatibility with previous versions of VirtualGL, the first
<code>vglclient</code> instance on a given machine will attempt to
listen on port 4242 for unencrypted connections and 4243 for SSL connections.
If it fails to obtain one of those ports, because another application
or another <code>vglclient</code> instance is already using them, then
<code>vglclient</code> will try to obtain a free port in the range
of 4200-4299.  Failing that, it will request a free port from the operating
system.</p>

<p>In a nutshell: if you only ever plan to run one X server at a time
on your client machine, which means that you&rsquo;ll only ever need
one instance of <code>vglclient</code> at a time, then it is sufficient
to open inbound ports 4242 and 4243 in your client machine&rsquo;s
firewall.  If you plan to run multiple X servers on your client machine,
which means that you will need to run multiple <code>vglclient</code>
instances, then you may wish to open ports 4200-4299.  Similarly, if
you are running <code>vglclient</code> on a multi-user TurboVNC or
Sun Ray server that has a firewall, then you may wish to open ports
4200-4299 in the server&rsquo;s firewall.  Opening ports 4200-4299
will accommodate up to 50 separate <code>vglclient</code> instances.
More instances than that cannot be accommodated on a firewalled machine,
unless the firewall is able to create rules based on application executables
instead of listening ports.</p>

<p>Note that it is not necessary to open any inbound ports in the firewall
to use the VGL Image Transport with <a href="#SSh_Tunneling">SSh
Tunneling</a><a name="idx0079"></a>.</p>

<hr class="break" />


<h1 id="hd009"><a name="file009"></a>9&nbsp;Using VirtualGL with TurboVNC</h1>

<p><a name="TurboVNC_Usage"></a></p>

<p>Referring to Chapter <a href="#Overview" class="ref">2</a>, the X11
Image Transport bypasses VirtualGL&rsquo;s internal image compressor
and instead draws the rendered 3D images to an X server using standard
X11 drawing commands.  Since this results in the images being sent
uncompressed to the X server, the X11 Image Transport is designed to
be used with an &ldquo;X Proxy.&rdquo;  An X proxy acts as a virtual
X server, receiving X11 commands from the application (and from VirtualGL),
rendering the X11 commands into images, compressing the resulting images,
and sending the compressed images over the network to a client or clients.</p>

<p>Since VirtualGL is sending rendered 3D images to the X proxy at a very
fast rate, the proxy must be able to compress the images very quickly
in order to keep up.  But, unfortunately, most X proxies can&rsquo;t.
They simply aren&rsquo;t designed for the types of full-screen video
workloads that VirtualGL generates. Therefore, the VirtualGL Project
provides an optimized X proxy called &ldquo;TurboVNC&rdquo;, which
is based on the
<span class="remote"><a href="http://www.realvnc.com/" class="remote">Virtual
Network Computing (VNC)</a></span><a name="idx0080"></a> standard (more
specifically, on the
<span class="remote"><a href="http://www.tightvnc.com" class="remote">TightVNC</a></span><a name="idx0081"></a>
variant thereof.)</p>

<p>On the surface, TurboVNC behaves very similarly to its parent project,
but TurboVNC has been tuned to provide interactive performance for
the types of full-screen video workloads that VirtualGL produces. 
On these types of image workloads, TurboVNC performs as much as an
order of magnitude faster than TightVNC, uses more than an order of
magnitude less CPU time to compress each frame, and it produces comparable
compression ratios.  Part of this speedup comes from the use of TurboJPEG,
the same high-speed vector-optimized JPEG codec used by the VGL Image
Transport.  Another large part of the speedup comes from bypassing
the color compression features of TightVNC.  TightVNC performs very
CPU-intensive analysis on each image tile to determine whether the
tile will compress better using color compression or JPEG.  But for
the types of images that a 3D application generates, it is almost never
the case that color compression compresses better than JPEG, so TurboVNC
bypasses this analysis to improve performance.  TurboVNC also has the
ability to hide network latency by decompressing and drawing a frame
on the client while the next frame is being fetched from the server,
and this can improve performance dramatically on high-latency connections.
TurboVNC additionally provides client-side double buffering, full support
for Solaris, and other tweaks.</p>


<h3 id="hd009000001">Advantages of TurboVNC (when compared to the VGL Image Transport)</h3>

<ul class="Itemize">
    <li class="Itemize asterisk">
        TurboVNC eliminates the need to send X11 traffic over the network,
        thus it performs very well on low-bandwidth, high-latency connections
        (such as broadband or long-haul T1 lines.)  The 3D application&rsquo;s
        GUI will load and render much faster (perhaps even orders of magnitude
        faster) with TurboVNC than with the VGL Image Transport on such connections.
    </li>
    <li class="Itemize asterisk">
        TurboVNC provides rudimentary collaboration capabilities.  Multiple
        clients can simultaneously view the same server session and pass around
        control of the keyboard and mouse.
    </li>
    <li class="Itemize asterisk">
        The TurboVNC client is stateless.  If the network hiccups or the client
        is otherwise disconnected, the session remains running on the server
        and can be rejoined from any machine on the network.
    </li>
    <li class="Itemize asterisk">
        No X server is required on the client machine.  This reduces the deployment
        cost and complexity for Windows clients.
    </li>
</ul>


<h3 id="hd009000002">Disadvantages of TurboVNC</h3>

<ul class="Itemize">
    <li class="Itemize asterisk">
        No seamless windows.  All application windows are constrained to a
        &ldquo;virtual desktop&rdquo;, which displays in a single window on
        the client machine.
    </li>
    <li class="Itemize asterisk">
        TurboVNC will generally	require about 20% more server CPU cycles to
        maintain the same frame rate as the VGL Image Transport, both because
        it has to compress more pixels in each frame	(an entire desktop rather
        than a single window) and because it has to perform 2D (X11) rendering
        as well as 3D rendering.
    </li>
    <li class="Itemize asterisk">
        TurboVNC does not support stereographic or overlay rendering.
    </li>
</ul>


<h2 id="hd009001">9.1&nbsp;Using TurboVNC and VirtualGL on the Same Server</h2>

<p><a name="TurboVNC_Usage_Local"></a></p>

<p>The most common (and optimal) way to use TurboVNC is to set it up on
the same server that is running VirtualGL.  This allows VirtualGL to
send its rendered 3D images to TurboVNC through shared memory rather
than sending them over a network.</p>

<div class="figure">
<img src="x11transport.png" alt="x11transport" class="figure" id="imgid_19" name="imgid_19"/>
</div>


<h3 id="hd009001001">Procedure</h3>

<ol class="Ordered numeric">
    <li class="Ordered">
        <em>Mac clients:</em> Start the Mac X11 application.
    </li>
    <li class="Ordered">
        Open a new Command Prompt/terminal window on your client machine. (<em>Mac
        clients:</em> in the X11 application, start a new xterm [Command-N]
        if one isn&rsquo;t already started.)
    </li>
    <li class="Ordered">
        In the new Command Prompt/terminal/xterm window, open a Secure Shell
        (SSh) session into the VirtualGL/TurboVNC server machine:
        <dl class="Description">
            <dt class="Description">Linux/Mac/Solaris clients</dt>
            <dd class="Description">
<pre class="verbatim">
ssh&nbsp;{user}@{server}
</pre>

            </dd>
            <dt class="Description">Windows clients</dt>
            <dd class="Description">
<pre class="verbatim">
&quot;c:\program&nbsp;files\turbovnc\putty&quot;&nbsp;{user}@{server}
</pre>

        Replace <em><code>{user}</code></em> with your user account name on
        the VirtualGL server and <em><code>{server}</code></em> with the hostname
        or IP address of that server.
            </dd>
        </dl>
    </li>
    <li class="Ordered">
        In the SSh session, start a TurboVNC server session:
<pre class="verbatim">
/opt/TurboVNC/bin/vncserver
</pre>

    </li>
    <li class="Ordered">
        Make a note of the X display number that the TurboVNC server process
        prints out, for instance: <br /><br /> <code>New&nbsp;'X'&nbsp;desktop&nbsp;is&nbsp;my_server:1</code>
        <br /><br /> If this is the first time that a TurboVNC server session
        has ever been run under this user account, TurboVNC will prompt for
        a VNC session password.
    </li>
    <li class="Ordered">
        The SSh session can now be exited, if desired.
    </li>
    <li class="Ordered">
        On the client machine, start the TurboVNC Viewer.
        <dl class="Description">
            <dt class="Description">Linux/Mac/Solaris clients</dt>
            <dd class="Description">
                 Open a new terminal/xterm and type
<pre class="verbatim">
/opt/TurboVNC/bin/vncviewer
</pre>

            </dd>
            <dt class="Description">Windows clients</dt>
            <dd class="Description">
                 Select <em>TurboVNC Viewer</em> in the <em>TurboVNC</em> Start Menu
                 group.
            </dd>
        </dl>
    </li>
    <li class="Ordered">
        A small dialog box will appear. <br /><br />
        <div class="table">
        <table class="standard">
          <thead class="standard">
          <tr class="head ">
            <th class="head standard">Windows TurboVNC viewer</th>
            <th class="head standard">Linux/Mac/Solaris TurboVNC viewer</th>
          </tr>
          </thead>
          <tr class="standard">
            <td class="standard"><img src="turbovnc1.png" alt="turbovnc1" class="inline" id="imgid_4" name="imgid_4"/></td>
            <td class="standard"><img src="turbovnc2.png" alt="turbovnc2" class="inline" id="imgid_5" name="imgid_5"/></td>
          </tr>
        </table>
        </div>
        
        <br /> Enter the X display name (hostname/IP address and display number)
        of the TurboVNC server in the &ldquo;VNC Server&rdquo; field, then
        click &ldquo;Connect&rdquo; (Windows) or press Enter (Linux/Mac/Solaris.)
    </li>
    <li class="Ordered">
        Another dialog box appears, prompting for the VNC session password.
        <br /><br />
        <div class="table">
        <table class="standard">
          <thead class="standard">
          <tr class="head ">
            <th class="head standard">Windows TurboVNC viewer</th>
            <th class="head standard">Linux/Mac/Solaris TurboVNC viewer</th>
          </tr>
          </thead>
          <tr class="standard">
            <td class="standard"><img src="turbovnc3.png" alt="turbovnc3" class="inline" id="imgid_6" name="imgid_6"/></td>
            <td class="standard"><img src="turbovnc4.png" alt="turbovnc4" class="inline" id="imgid_7" name="imgid_7"/></td>
          </tr>
        </table>
        </div>
        
        <br /> Enter the TurboVNC session password and click &ldquo;OK&rdquo;
        (Windows) or press Enter (Linux/Mac/Solaris.) <br /><br /> A TurboVNC
        desktop window should appear on your client machine.  This window contains
        a virtual X server with which you can interact to launch X-Windows
        applications on the TurboVNC server machine.
    </li>
    <li class="Ordered">
        Open a new terminal inside the TurboVNC desktop.
    </li>
    <li class="Ordered">
        In the terminal, start a 3D application using VirtualGL:
<pre class="verbatim">
/opt/VirtualGL/bin/vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        VirtualGL will detect that the X display connection is local and will
        automatically enable the X11 Image Transport.
        <br class="itempara" />Consult Chapter <a href="#Advanced_Configuration" class="ref">19</a>
        for more information on <code>vglrun</code> command line options.
    </li>
</ol>


<h2 id="hd009002">9.2&nbsp;Using TurboVNC When VirtualGL Is Running on a Different Machine</h2>

<p><a name="TurboVNC_Usage_Remote"></a></p>

<div class="figure">
<img src="vgltransportservernetwork.png" alt="vgltransportservernetwork" class="figure" id="imgid_20" name="imgid_20"/>
</div>

<p>If TurboVNC and VirtualGL are running on different servers, then it
is desirable to use the VGL Image Transport to send images from the
VirtualGL server to the TurboVNC server.  It is also desirable to disable
image compression in the VGL Image Transport.  Otherwise, the images
would have to be compressed by the VirtualGL server, decompressed by
the VirtualGL Client, then recompressed by the TurboVNC server, which
is a waste of CPU resources. However, sending images uncompressed over
a network requires a fast network (generally, Gigabit Ethernet or faster.)
So there needs to be a fast link between the VirtualGL server and the
TurboVNC server for this procedure to perform well.</p>


<h3 id="hd009002001">Procedure</h3>

<p>The procedure for using the VGL Image Transport to transmit images
from a VirtualGL server to a TurboVNC server is the same as the
<a href="#X11_Forwarding">procedure</a><a name="idx0082"></a> for using
the VGL Image Transport to transmit images to a remote X server, with
the following notable differences:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        The &ldquo;client&rdquo; in this case is really the TurboVNC server
        machine.
    </li>
    <li class="Ordered">
        The &ldquo;X server&rdquo; is really the TurboVNC server session.
    </li>
    <li class="Ordered">
        Once connected to the VirtualGL server with SSh, it is recommended
        that you disable image compression in the VGL Image Transport by either
        setting the environment variable <code>VGL_COMPRESS</code> to <code>rgb</code>
        or passing an argument of <code>-c&nbsp;rgb</code> to <code>vglrun</code>
        when launching VirtualGL.  Otherwise, VirtualGL will detect that the
        connection to the X server is remote, and it will automatically try
        to enable JPEG compression.
    </li>
</ol>


<h2 id="hd009003">9.3&nbsp;Disconnecting and Killing the TurboVNC Session</h2>

<p>Closing the TurboVNC viewer disconnects from the TurboVNC server session,
but the TurboVNC server session is still running on the server machine
(as are any applications that you may have started in it), and you
can reconnect to the session at any time.</p>

<p>To kill a TurboVNC server session:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Using SSh (<code>c:\Program&nbsp;Files\TurboVNC\putty.exe</code> on
        Windows clients), log into the machine that is running the TurboVNC
        server session that you wish to kill.<br /> &hellip; or
        &hellip;<br /> Using the TurboVNC Viewer, connect to the TurboVNC server
        session that you wish to kill, and open a new terminal in that TurboVNC
        session.
    </li>
    <li class="Ordered">
        Type the following command:
<pre class="verbatim">
/opt/TurboVNC/bin/vncserver&nbsp;-kill&nbsp;:{n}
</pre>

        Replace <em><code>{n}</code></em> with the X display number of the
        TurboVNC server session you wish to kill.
    </li>
</ol>

<p>To list the X display numbers and process ID&rsquo;s of all TurboVNC
server sessions that are currently running under your user account
on this machine, run</p>

<pre class="verbatim">
/opt/TurboVNC/bin/vncserver&nbsp;-list
</pre>


<h2 id="hd009004">9.4&nbsp;Using TurboVNC in a Web Browser</h2>

<p>When a TurboVNC server session is created, it automatically launches
a miniature web server that serves up a Java TurboVNC viewer applet.
This Java TurboVNC viewer can be used to connect to the TurboVNC server
from a machine that does not have a native TurboVNC viewer installed
(or a machine for which no native TurboVNC viewer is available.)  The
Java viewer is significantly slower than the native viewer on high-speed
networks, but on low-speed networks the Java viewer and native viewers
have comparable performance.  The Java viewer does not currently support
double buffering.</p>

<p>To use the Java TurboVNC viewer, point your web browser to:</p>

<p><code>http://</code><em><code>{turbovnc_server}</code></em><code>:{5800+</code><em><code>n</code></em><code>}</code></p>

<p>where <em><code>{turbovnc_server}</code></em> is the hostname or IP
address of the TurboVNC server machine, and <em><code>n</code></em>
is the X display number of the TurboVNC server session to which you
want to connect.</p>

<p><em>Example:</em> If the TurboVNC server is running on X display <code>my_server:1</code>,
then point your web browser to:</p>

<p><code>http://my_server:5801</code></p>


<h2 id="hd009005">9.5&nbsp;Optimizing TurboVNC&rsquo;s Performance for Different Network Types</h2>

<p>The level of image compression in TurboVNC can be adjusted to balance
the (sometimes conflicting) goals of high image quality and high performance.
The more TurboVNC compresses an image, the more grainy the resulting
image becomes.  But these lower quality levels also require less network
bandwidth and can thus improve the overall performance of TurboVNC
on slower networks.</p>

<p>There are three options that control the level of image compression
in TurboVNC:</p>

<dl class="Description">
    <dt class="Description">Image compression type</dt>
    <dd class="Description">
         Either &ldquo;JPEG&rdquo; or &ldquo;None (RGB)&rdquo;.  &ldquo;None
         (RGB)&rdquo; turns off image compression altogether, which is useful
         when connecting to a TurboVNC server running on the same machine as
         the viewer or to a TurboVNC server located across a gigabit or faster
         network.  Disabling image compression greatly reduces the CPU usage
         on the server and client, at the expense of greatly increasing the
         network usage.
    </dd>
    <dt class="Description">JPEG image quality</dt>
    <dd class="Description">
         Lower quality levels produce grainier JPEG images with more noticeable
         compression artifacts, but lower quality levels also use less network
         bandwidth and CPU power.  Refer to Section <a href="#VGL_QUAL" class="ref">19.1</a>
         for more details.
    </dd>
    <dt class="Description">JPEG chrominance subsampling</dt>
    <dd class="Description">
         After converting the image from RGB to YUV, chrominance subsampling
         discards some of the U and V (chrominance) components to save space.
         1x subsampling retains the chrominance components for all pixels,
         2x subsampling retains the chrominance components for every other
         pixel, 4x subsampling retains the chrominance components for every
         fourth pixel, and grayscale throws out all of the chrominance components.
         Refer to Section <a href="#VGL_SUBSAMP" class="ref">19.1</a> for more
         details.
    </dd>
</dl>

<p>In the Windows TurboVNC Viewer, these parameters can be adjusted by
accessing the Options dialog box (click the &ldquo;Options&rdquo; button
in the &ldquo;TurboVNC Connection&rdquo; dialog box or, after connecting
to the server, click on the Connection Options button in the toolbar.)
In the Unix TurboVNC viewer, press F8 after connecting to bring up
the options menu.  In the Java viewer, click on the Options button
at the top of the browser window.</p>

<p>The TurboVNC Viewer provides three &ldquo;connection profiles&rdquo;,
corresponding to three of the most useful levels of JPEG image compression:</p>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">Connection profile</th>
    <th class="head standard">JPEG image quality</th>
    <th class="head standard">JPEG chrominance subsampling</th>
    <th class="head standard">Notes</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard">&ldquo;Low Quality&rdquo;</td>
    <td class="standard">30</td>
    <td class="standard">4x</td>
    <td class="standard">This is generally about the lowest usable JPEG quality.  It produces very noticeable image compression artifacts but will allow TurboVNC to perform optimally on broadband connections.  If image quality is more critical than performance, then use one of the other connection profiles or take advantage of the &ldquo;Lossless Refresh&rdquo; feature.</td>
  </tr>
  <tr class="standard">
    <td class="standard">&ldquo;Medium Quality&rdquo;</td>
    <td class="standard">80</td>
    <td class="standard">2x</td>
    <td class="standard">This profile produces some minor, but generally not very noticeable, image compression artifacts.  All else being equal, this profile uses approximately twice the network bandwidth of the &ldquo;Low Quality&rdquo; profile and half the bandwidth of the &ldquo;High Quality&rdquo; profile, making it appropriate for medium-speed networks such as 10 Megabit ethernet.</td>
  </tr>
  <tr class="standard">
    <td class="standard">&ldquo;High Quality&rdquo;</td>
    <td class="standard">95</td>
    <td class="standard">1x</td>
    <td class="standard">This profile should be perceptually lossless (that is, it should produce no noticeable image compression artifacts) for most applications.  It requires a great deal of network bandwidth, however, and is generally not recommended except on 50 Megabit/second and faster networks.</td>
  </tr>
</table>
</div>


<p>In the Windows TurboVNC Viewer, there are three buttons in the &ldquo;TurboVNC
Connection&rdquo; dialog box that allow you to easily select the connection
profile. In the Java viewer, the same thing is accomplished by clicking
the &ldquo;Options&rdquo; button at the top of the browser window.
With the Linux/Mac/Solaris TurboVNC Viewer, the &ldquo;High Quality&rdquo;
profile is the default, and you can use the <code>-lowqual</code> and
<code>-medqual</code> command line options to <code>vncviewer</code>
to switch to the &ldquo;Low Quality&rdquo; or &ldquo;Medium Quality&rdquo;
profiles.  You can also press the F8 key after connecting to pop up
a menu from which you can select a different connection profile.</p>


<h3 id="hd009005001">Lossless Refresh</h3>

<p>TurboVNC can optionally encode images as RGB, which is fully lossless
and uncompressed, but this mode does not perform well except on extremely
fast networks.  Another option for quality-critical applications is
the &ldquo;Lossless Refresh&rdquo; feature.  Lossless Refresh causes
the server to send a mathematically lossless (Zlib-compressed RGB)
copy of the current screen to the viewer.  So, for instance, a user
can rotate/pan/zoom an object in their application using a very lossy
quality setting, then when that user is ready to interpret or analyze
the object closely, they can request a lossless refresh of the screen.</p>

<p>To perform a lossless refresh, press CTRL-ALT-SHIFT-L in the Windows
TurboVNC Viewer (or click on the Lossless Refresh toolbar icon.)  In
the Unix/Linux TurboVNC Viewer, select &ldquo;Lossless Refresh&rdquo;
from the F8 popup menu.  In the Java TurboVNC Viewer, click the &ldquo;Lossless
Refresh&rdquo; button at the top of the browser window.</p>


<h2 id="hd009006">9.6&nbsp;Securing a TurboVNC Connection</h2>

<p>Normally, the connection between the TurboVNC server and the TurboVNC
viewer is completely unencrypted, but securing that connection can
be easily accomplished by using the port forwarding feature of Secure
Shell (SSh.)  After you have started a TurboVNC server session on the
server machine, open a new SSh connection into the server machine using
the following command line:</p>

<dl class="Description">
    <dt class="Description">Linux/Mac/Solaris clients</dt>
    <dd class="Description">
<pre class="verbatim">
ssh&nbsp;-L&nbsp;{5900+n}:localhost:{5900+n}&nbsp;{user}@{server}
</pre>

    </dd>
    <dt class="Description">Windows clients</dt>
    <dd class="Description">
<pre class="verbatim">
&quot;c:\program&nbsp;files\turbovnc\putty&quot;&nbsp;-L&nbsp;{5900+n}:localhost:{5900+n}&nbsp;{user}@{server}
</pre>

    </dd>
</dl>

<p>Replace <em><code>{user}</code></em> with your user account name on
the TurboVNC server and <em><code>{server}</code></em> with the hostname
or IP address of that server.  Replace <em><code>n</code></em> with
the X display number of the TurboVNC server session to which you want
to connect.</p>

<p>For instance, if you wish to connect to display <code>:1</code> on
server <code>my_server</code> using user account <code>my_user</code>,
you would type:</p>

<dl class="Description">
    <dt class="Description">Linux/Mac/Solaris clients</dt>
    <dd class="Description">
<pre class="verbatim">
ssh&nbsp;-L&nbsp;5901:localhost:5901&nbsp;my_user@my_server
</pre>

    </dd>
    <dt class="Description">Windows clients</dt>
    <dd class="Description">
<pre class="verbatim">
&quot;c:\program&nbsp;files\turbovnc\putty&quot;&nbsp;-L&nbsp;5901:localhost:5901&nbsp;my_user@my_server
</pre>

    </dd>
</dl>

<p>After the SSh connection has been established, you can then launch
the TurboVNC viewer and point it to <code>localhost:</code><em><code>{n}</code></em>
(<code>localhost:1</code> in the above example.)</p>


<h3 id="hd009006001">Performance Notes</h3>

<p>For LAN connections and other high-speed networks, tunneling the TurboVNC
connection over SSh will reduce performance by as much as 20-40%. 
But for wide-area networks, broadband, etc., there is no performance
penalty for using SSh tunneling with TurboVNC.</p>


<h2 id="hd009007">9.7&nbsp;Further Reading</h2>

<p>For more detailed instructions on the usage of TurboVNC:</p>

<dl class="Description">
    <dt class="Description">Linux and Solaris</dt>
    <dd class="Description">
        Refer to the TurboVNC man pages:
<pre class="verbatim">
man&nbsp;-M&nbsp;/opt/TurboVNC/man&nbsp;{vncserver&nbsp;|&nbsp;Xvnc&nbsp;|&nbsp;vncviewer&nbsp;|&nbsp;vncconnect&nbsp;|&nbsp;vncpasswd}
</pre>

    </dd>
    <dt class="Description">Windows</dt>
    <dd class="Description">
        Use the embedded help feature (the question mark button in the upper
        right of the TurboVNC Viewer window.)
    </dd>
</dl>

<p>The TightVNC documentation:</p>

<p><a href="http://www.tightvnc.com/docs.html">http://www.tightvnc.com/docs.html</a></p>

<p>might also be helpful, since TurboVNC is based on TightVNC and shares
many of its features.</p>

<hr class="break" />


<h1 id="hd0010"><a name="file010"></a>10&nbsp;Using VirtualGL with Other X Proxies</h1>

<p><a name="X11_Proxy_Usage"></a></p>

<p>The <a href="#TurboVNC_Usage">previous chapter</a><a name="idx0083"></a>
described how to use VirtualGL with TurboVNC, but much of this information
is also applicable to other X proxies, such as RealVNC, NX, etc.  Generally,
none of these other solutions will provide anywhere near the performance
of TurboVNC, but some of them have capabilities that TurboVNC lacks
(NX, for instance, can do seamless windows.)</p>

<p>VirtualGL reads the value of the <code>DISPLAY</code> environment variable
to determine whether to enable the X11 Image Transport by default.
If <code>DISPLAY</code> begins with a colon (&ldquo;<code>:</code>&rdquo;)
or with &ldquo;<code>unix:</code>&rdquo;, then VirtualGL will assume
that the X server connection is local and will enable the X11 Image
Transport as the default.  This should effectively make the X11 Image
Transport the default for most X proxies, but if for some reason that
doesn&rsquo;t occur, then you can force the use of the X11 Image Transport
by setting <code>VGL_COMPRESS</code> to <code>proxy</code> or passing
an argument of <code>-c&nbsp;proxy</code> to <code>vglrun</code>.</p>

<hr class="break" />


<h1 id="hd0011"><a name="file011"></a>11&nbsp;Using VirtualGL in a Sun Ray Environment</h1>

<p><a name="Sun_Ray_Usage"></a></p>

<p>As described in Chapter <a href="#Overview" class="ref">2</a>, the
Sun Ray environment consists of both an X proxy and an ultra-thin hardware
client.  If the proprietary VirtualGL Sun Ray plugin is not used, then
the Sun Ray server can be treated just like any other X proxy and used
with either the X11 Image Transport or the VGL Image Transport, as
described in Chapter <a href="#TurboVNC_Usage" class="ref">9</a> and
Chapter <a href="#X11_Proxy_Usage" class="ref">10</a>.</p>

<p>If, however, the Sun Ray plugin is installed on the VirtualGL server,
then a slightly different procedure is required to connect to that
server and use the Sun Ray Image Transport.  This procedure assumes
that VirtualGL is running on a different machine than the Sun Ray server.</p>


<h3 id="hd0011000001">Procedure</h3>

<ol class="Ordered numeric">
    <li class="Ordered">
        In the Sun Ray session, open a new terminal window.
    </li>
    <li class="Ordered">
        In the same terminal window, open a Secure Shell (SSh) session into
        the VirtualGL server:
<pre class="verbatim">
ssh&nbsp;-X&nbsp;{user}@{server}
</pre>

        Replace <em><code>{user}</code></em> with your user account name on
        the VirtualGL server and <em><code>{server}</code></em> with the hostname
        or IP address of that server.
    </li>
    <li class="Ordered">
        In the SSh session, start a 3D application using VirtualGL:
<pre class="verbatim">
/opt/VirtualGL/bin/vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        Consult Chapter <a href="#Advanced_Configuration" class="ref">19</a>
        for more information on <code>vglrun</code> command line options.
    </li>
</ol>

<p>Note that this procedure is substantially similar to the <a href="#X11_Forwarding">X11
Forwarding</a><a name="idx0084"></a> procedure used with the VGL Image
Transport, except that it invokes <code>ssh</code> directly rather
than using the <code>vglconnect</code> wrapper script.  <code>vglconnect</code>
launches <code>vglclient</code>, and <code>vglclient</code> is not
needed when using the Sun Ray Image Transport.</p>

<p>If the VirtualGL Sun Ray plugin is installed on a VirtualGL server
machine, then VirtualGL will try to use the Sun Ray Image Transport
when displaying 3D applications from that server to a Sun Ray.  However,
the Sun Ray Image Transport requires that the Sun Ray client be on
a network that is accessible from the VirtualGL server.  Some Sun Ray
deployments place the clients on a private network that is visible
only to the Sun Ray server, and the Sun Ray Image Transport cannot
be used in such cases (unless VirtualGL is running on the Sun Ray server
itself, but that defeats the purpose of the Sun Ray Image Transport.)
If VirtualGL detects that it is running in a Sun Ray environment but
is unable to use the Sun Ray Image Transport, then it will fall back
to using the X11 Image Transport.</p>

<hr class="break" />


<h1 id="hd0012"><a name="file012"></a>12&nbsp;<code>vglrun</code> and Shell Scripts</h1>

<p><code>vglrun</code> can be used to launch either binary executables
or shell scripts, but there are a few things to keep in mind when using
<code>vglrun</code> to launch a shell script.  When you <code>vglrun</code>
a shell script, the VirtualGL faker library will be preloaded into
every executable that the script launches.  Normally this is innocuous,
but if the script calls any executables that are setuid and/or setgid,
then the dynamic linker will refuse to preload the VirtualGL faker
library into those executables.  The following warning will be printed
out for each setuid/setgid executable that the script tries to launch:</p>

<dl class="Description">
    <dt class="Description">Linux</dt>
    <dd class="Description">
    </dd>
</dl>

<pre class="verbatim">
ERROR:&nbsp;ld.so:&nbsp;object&nbsp;'librrfaker.so'&nbsp;from&nbsp;LD_PRELOAD&nbsp;cannot&nbsp;be&nbsp;preloaded:&nbsp;ignored.
</pre>

<dl class="Description">
    <dt class="Description">Solaris</dt>
    <dd class="Description">
    </dd>
</dl>

<pre class="verbatim">
ld.so.1:&nbsp;warning:&nbsp;librrfaker.so:&nbsp;open&nbsp;failed:&nbsp;No&nbsp;such&nbsp;file&nbsp;in&nbsp;secure&nbsp;directories
</pre>

<p>On Solaris and on newer versions of Linux (Enterprise Linux 3 and later),
the executable will continue to run, but without VirtualGL preloaded
into it.  That may be a problem, if the setuid/setgid executable was
a 3D application that was intended to be used with VirtualGL.  To further
complicate matters, some older versions of Linux will refuse to launch
setuid/setgid executables at all if one attempts to preload VirtualGL
into them.</p>

<p>There are a couple of ways to work around this issue.  Probably the
safest way is to simply edit the application script and make it store
the value of the <code>LD_PRELOAD</code> environment variables until
right before the application executable is launched.  For instance,
take the following application script (please):</p>

<p>Initial contents of <code>application.sh</code>:</p>

<pre class="verbatim">
#!/bin/sh
some_setuid_executable
some_application_executable
</pre>

<p>You could modify the script as follows:</p>

<dl class="Description">
    <dt class="Description">Solaris</dt>
    <dd class="Description">
        Modified <code>application.sh</code>:
    </dd>
</dl>

<pre class="verbatim">
#!/bin/sh
LD_PRELOAD_32_SAVE=$LD_PRELOAD_32
LD_PRELOAD_64_SAVE=$LD_PRELOAD_64
LD_PRELOAD_32=
LD_PRELOAD_64=
export&nbsp;LD_PRELOAD_32&nbsp;LD_PRELOAD_64

some_setuid_executable

LD_PRELOAD_32=$LD_PRELOAD_32_SAVE
LD_PRELOAD_64=$LD_PRELOAD_64_SAVE
export&nbsp;LD_PRELOAD_32&nbsp;LD_PRELOAD_64

some_application_executable
</pre>

<dl class="Description">
    <dt class="Description">Linux</dt>
    <dd class="Description">
        Modified <code>application.sh</code>:
    </dd>
</dl>

<pre class="verbatim">
#!/bin/sh
LD_PRELOAD_SAVE=$LD_PRELOAD
LD_PRELOAD=
export&nbsp;LD_PRELOAD

some_setuid_executable

LD_PRELOAD=$LD_PRELOAD_SAVE
export&nbsp;LD_PRELOAD

some_application_executable
</pre>

<p>You can also force VirtualGL to be preloaded into setuid/setgid executables,
but please be aware of the security ramifications of this before you
do it.  By applying one of the following workarounds, you are essentially
telling the operating system that you trust the security and stability
of the VirtualGL code as much as you trust the security and stability
of the operating system. And while we&rsquo;re flattered, we&rsquo;re
not sure that we&rsquo;re necessarily deserving of that accolade, so
if you are in a security critical environment, apply the appropriate
level of paranoia here.</p>

<p>To force VirtualGL to be preloaded into setuid/setgid executables on
Linux, make <code>librrfaker.so</code> a setuid executable.  To do
this, run the following command as root:</p>

<pre class="verbatim">
chmod&nbsp;u+s&nbsp;/usr/lib/librrfaker.so
</pre>

<p>On 64-bit Linux systems, also run:</p>

<pre class="verbatim">
chmod&nbsp;u+s&nbsp;/usr/lib64/librrfaker.so
</pre>

<p>On Solaris, you can force VirtualGL to be preloaded into setuid/setgid
executables by adding the VirtualGL library directories to the Solaris
&ldquo;secure path.&rdquo;  Solaris keeps a tight lid on what goes
into <code>/usr/lib</code> and <code>/lib</code>, and by default, it
will only allow libraries in those paths to be preloaded into an executable
that is setuid and/or setgid.  Generally, 3rd party packages are verboden
from installing anything into <code>/usr/lib</code> or <code>/lib</code>.
But you can use the <code>crle</code> utility to add other directories
to the operating system&rsquo;s list of secure paths.  In the case
of VirtualGL, you would execute the following commands (as root):</p>

<pre class="verbatim">
crle&nbsp;-u&nbsp;-s&nbsp;/opt/SUNWvgl/lib
crle&nbsp;-64&nbsp;-u&nbsp;-s&nbsp;/opt/SUNWvgl/lib/64
</pre>

<p><code>vglrun</code> on Solaris has two additional options that are
relevant to launching scripts:</p>

<pre class="verbatim">
vglrun&nbsp;-32&nbsp;{script}
</pre>

<p>will preload VirtualGL only into 32-bit executables called by a script,
whereas</p>

<pre class="verbatim">
vglrun&nbsp;-64&nbsp;{script}
</pre>

<p>will preload VirtualGL only into 64-bit executables.  So if, for instance,
the setuid executable that the script is invoking is 32-bit and the
application executable is 64-bit, then you could use <code>vglrun&nbsp;-64</code>
to launch the application script.</p>

<hr class="break" />


<h1 id="hd0013"><a name="file013"></a>13&nbsp;Using VirtualGL with Applications That Manually Load OpenGL</h1>

<p><a name="dlopen"></a></p>

<p>The lion&rsquo;s share of OpenGL applications are dynamically linked
against <code>libGL.so</code>, and thus <code>libGL.so</code> is automatically
loaded whenever the application loads.  Whenever <code>vglrun</code>
is used to launch such applications, VirtualGL is loaded ahead of <code>libGL.so</code>,
meaning that OpenGL and GLX symbols are resolved from VirtualGL first
and the &ldquo;real&rdquo; OpenGL library second.</p>

<p>However, some applications (particularly games) are not dynamically
linked against <code>libGL.so</code>.  These applications typically
call <code>dlopen()</code> and <code>dlsym()</code> later on in the
program&rsquo;s execution to manually load OpenGL and GLX symbols from
<code>libGL.so</code>.  Such applications also generally provide a
mechanism (usually either an environment variable or a command line
argument) which allows the user to specify a library that can be loaded
instead of <code>libGL.so</code>.</p>

<p>So let&rsquo;s assume that you just downloaded the latest version of
the Linux game Foo Wars from the Internet, and (for whatever reason)
you want to run the game in a VNC session.  The game provides a command
line switch <code>-g</code> which can be used to specify an OpenGL
library to load other than <code>libGL.so</code>.  You would launch
the game using a command line such as this:</p>

<pre class="verbatim">
vglrun&nbsp;foowars&nbsp;-g&nbsp;/usr/lib/librrfaker.so
</pre>

<p>You still need to use <code>vglrun</code> to launch the game, because
VirtualGL must also intercept a handful of X11 calls.  Using <code>vglrun</code>
allows VGL to intercept these calls, whereas using the game&rsquo;s
built-in mechanism for loading a substitute OpenGL library allows VirtualGL
to intercept the GLX and OpenGL calls.</p>

<p>In some cases, the application doesn&rsquo;t provide an override mechanism
such as the above.  In these cases, you should pass an argument of
<code>-dl</code> to <code>vglrun</code> when starting the application.
For example:</p>

<pre class="verbatim">
vglrun&nbsp;-dl&nbsp;foowars
</pre>

<p>Passing <code>-dl</code> to <code>vglrun</code> forces another library
to be loaded ahead of VirtualGL and <code>libGL.so</code>.  This new
library intercepts any calls to <code>dlopen()</code> and forces the
application to open VirtualGL instead of <code>libGL.so</code>.</p>

<p>Chapter <a href="#Application_Recipes" class="ref">15</a> contains
specific recipes for getting a variety of games and other applications
to work with VirtualGL.</p>

<hr class="break" />


<h1 id="hd0014"><a name="file014"></a>14&nbsp;Using VirtualGL with Chromium and ModViz VGP</h1>

<p><a name="Chromium"></a></p>

<p>Chromium is a powerful framework for performing various types of parallel
OpenGL rendering.  It is usually used on clusters of commodity Linux
PC&rsquo;s to divide up the task of rendering scenes with large geometries
or large pixel counts (such as when driving a display wall.)  Chromium
is most often used in one of three configurations:</p>

<ol class="Ordered numeric">
    <li class="Ordered" value="1">
        Sort-First Rendering (Image-Space Decomposition)
    </li>
    <li class="Ordered" value="2">
        Sort-First Rendering (Image-Space Decomposition) with Readback
    </li>
    <li class="Ordered" value="3">
        Sort-Last Rendering (Object-Space Decomposition)
    </li>
</ol>


<h2 id="hd0014001">14.1&nbsp;Configuration 1: Sort-First Rendering (Image-Space Decomposition)</h2>

<div class="figure">
<img src="chromium-displaywall.png" alt="chromium-displaywall" class="figure" id="imgid_21" name="imgid_21"/>
</div>

<p>Sort-First Rendering (Image-Space Decomposition) is used to overcome
the fill rate limitations of individual graphics cards.  When configured
to use sort-first rendering, Chromium divides up the scene based on
which polygons will be visible in a particular section of the final
image.  It then instructs each node of the cluster to render only the
polygons that are necessary to generate the image section (&ldquo;tile&rdquo;)
for that node.  This is primarily used to drive high-resolution displays
that would be impractical to drive from a single graphics card due
to limitations in the card&rsquo;s framebuffer memory, processing power,
or both.  Configuration 1 could be used, for instance, to drive a CAVE,
video wall, or even an extremely high-resolution monitor.  In this
configuration, each Chromium node generally uses all of its screen
real estate to render a section of the multi-screen image.</p>

<p>VirtualGL is generally not very useful with Configuration 1.  You could
theoretically install a separate copy of VirtualGL on each display
node and use it to redirect the output of each <code>crserver</code>
instance to a multi-screen X server running elsewhere on the network.
But there would be no way to synchronize the screens on the remote
end.  Chromium uses DMX to synchronize the screens in a multi-screen
configuration, and VirtualGL would have to be made DMX-aware for it
to perform the same job.  Maybe at some point in the future &hellip;
If you have a need for such a configuration,
<span class="remote"><a href="http://sourceforge.net/users/dcommander" class="remote">let
us know</a></span><a name="idx0085"></a>.</p>


<h2 id="hd0014002">14.2&nbsp;Configuration 2: Sort-First Rendering (Image-Space Decomposition) with Readback</h2>

<div class="figure">
<img src="chromium-sortfirst.png" alt="chromium-sortfirst" class="figure" id="imgid_22" name="imgid_22"/>
</div>

<p>Configuration 2 uses the same sort-first principle as Configuration
1, except that each tile is only a fraction of a single screen, and
the tiles are recombined into a single window on Node 0.  This configuration
is perhaps the least often used of the three, but it is useful in cases
where the scene contains a large amount of textures (such as in volume
rendering) and thus rendering the whole scene on a single node would
be prohibitively slow due to fill rate limitations.</p>

<p>In this configuration, the application is allowed to choose a visual,
create an X window, and manage the window as it would normally do.
But all other OpenGL and GLX activity is intercepted by the Chromium
App Faker (CrAppFaker) so that the rendering task can be split up among
the rendering nodes.  Once each node has rendered its section of the
final image, the tiles get passed back to a Chromium Server (CrServer)
process running on Node 0.  This CrServer process attaches to the previously-created
application window and draws the pixels into it using <code>glDrawPixels()</code>.</p>

<p>The general strategy for making this work with VirtualGL is to first
make it work without VirtualGL and then insert VirtualGL only into
the processes that run on Node 0.  VirtualGL must be inserted into
the CrAppFaker process to prevent CrAppFaker from sending <code>glXChooseVisual()</code>
calls to the X server (which would fail if the X server is a VNC server
or otherwise does not provide GLX.)  VirtualGL must be inserted into
the CrServer process on Node 0 to prevent it from sending <code>glDrawPixels()</code>
calls to the X server (which would effectively send uncompressed images
over the network.)  Instead, VirtualGL forces CrServer to draw into
a Pbuffer, and VGL takes charge of transmitting those pixels to the
destination X server in the most efficient way possible.</p>

<p>Since Chromium uses <code>dlopen()</code> to load the system&rsquo;s
OpenGL library, preloading VirtualGL into the CrAppFaker and CrServer
processes using <code>vglrun</code> is not sufficient.  Fortunately,
Chromium provides an environment variable, <code>CR_SYSTEM_GL_PATH</code>,
which allows one to specify an alternate path in which it will search
for the system&rsquo;s <code>libGL.so</code>.  The VirtualGL packages
for Linux and Solaris include a symbolic link named <code>libGL.so</code>
which really points to the VirtualGL faker library (<code>librrfaker.so</code>)
instead.  This symbolic link is located in its own isolated directory,
so that directory can be passed to Chromium in the <code>CR_SYSTEM_GL_PATH</code>
environment variable, thus causing Chromium to load VirtualGL rather
than the &ldquo;real&rdquo; OpenGL library. Refer to the following
table:</p>

<p><a name="CR_SYSTEM_GL_PATH_Table"></a></p>

<div class="table">
<table class="standard" align="center">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">32-bit Applications</th>
    <th class="head standard">64-bit Applications</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard"><code>/opt/VirtualGL/fakelib</code></td>
    <td class="standard"><code>/opt/VirtualGL/fakelib/64</code></td>
  </tr>
</table>
<div class="tableNote" style="text-align=center;"><code>CR_SYSTEM_GL_PATH</code> setting required to use VirtualGL with Chromium</div>
</div>


<p>Running the CrServer in VirtualGL is simply a matter of setting this
environment variable and then invoking <code>crserver</code> with <code>vglrun</code>.
For example:</p>

<pre class="verbatim">
export&nbsp;CR_SYSTEM_GL_PATH=/opt/VirtualGL/fakelib
vglrun&nbsp;crserver
</pre>

<p>In the case of CrAppFaker, it is also necessary to set <code>VGL_GLLIB</code>
to the location of the &ldquo;real&rdquo; OpenGL library (example:
<code>/usr/lib/libGL.so.1</code>.) CrAppFaker creates its own fake
version of <code>libGL.so</code> which is really just a copy of Chromium&rsquo;s
<code>libcrfaker.so</code>.  So VirtualGL, if left to its own devices,
will unwittingly try to load <code>libcrfaker.so</code> instead of
the &ldquo;real&rdquo; OpenGL library.  Chromium&rsquo;s <code>libcrfaker.so</code>
will in turn try to load VirtualGL again, and an endless loop will
occur.</p>

<p>So what we want to do is something like this:</p>

<pre class="verbatim">
export&nbsp;CR_SYSTEM_GL_PATH=/opt/VirtualGL/fakelib
export&nbsp;VGL_GLLIB=/usr/lib/libGL.so.1
crappfaker
</pre>

<p>CrAppFaker will copy the application to a temp directory and then copy
<code>libcrfaker.so</code> to that same directory, renaming it as <code>libGL.so</code>.
So when the application is started, it loads <code>libcrfaker.so</code>
instead of <code>libGL.so</code>. <code>libcrfaker.so</code> will then
load VirtualGL instead of the &ldquo;real&rdquo; libGL, because we&rsquo;ve
overridden <code>CR_SYSTEM_GL_PATH</code> to make Chromium find VirtualGL&rsquo;s
fake <code>libGL.so</code> first.  VirtualGL will then use the library
specified in <code>VGL_GLLIB</code> to make any &ldquo;real&rdquo;
OpenGL calls that it needs to make.</p>

<p>Note that <code>crappfaker</code> should not be invoked with <code>vglrun</code>.</p>

<p>So, putting this all together, here is an example of how you might
start a sort-first rendering job using Chromium and VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Start the mothership on Node 0 with an appropriate configuration for
        performing sort-first rendering with readback
    </li>
    <li class="Ordered">
        Start <code>crserver</code> on each of the rendering nodes
    </li>
    <li class="Ordered">
        On Node 0, set <code>CR_SYSTEM_GL_PATH</code> to the appropriate value
        for the operating system and application type (see table above)
    </li>
    <li class="Ordered">
        On Node 0, <code>vglrun&nbsp;crserver&nbsp;&amp;</code>
    </li>
    <li class="Ordered">
        On Node 0, set <code>VGL_GLLIB</code> to the location of the &ldquo;real&rdquo;
        libGL (example: <code>/usr/lib/libGL.so.1</code> or <code>/usr/lib64/libGL.so.1</code>.)
    </li>
    <li class="Ordered">
        On Node 0, launch <code>crappfaker</code> (do not use <code>vglrun</code>
        here)
    </li>
</ol>

<p>Again, it&rsquo;s always a good idea to make sure this works without
VirtualGL before adding VirtualGL into the mix.</p>


<h3 id="hd0014002001">Using VirtualGL to Force Pbuffer Rendering</h3>

<p>In the procedure above, VirtualGL can also be used on the rendering
nodes to redirect the rendering commands from <code>crserver</code>
into a Pbuffer instead of a window.  If you wish to do this, then perform
the following procedure in place of step 2 above:</p>

<p>On each of the rendering nodes,</p>

<ul class="Itemize">
    <li class="Itemize asterisk">
        set <code>VGL_READBACK=0</code>
    </li>
    <li class="Itemize asterisk">
        set <code>CR_SYSTEM_GL_PATH</code> to the appropriate value based on
        the rendering node&rsquo;s operating system type and whether <code>crserver</code>
        was compiled as a 32-bit or 64-bit app on that node (see table above)
    </li>
    <li class="Itemize asterisk">
        <code>vglrun&nbsp;crserver</code>
    </li>
</ul>


<h2 id="hd0014003">14.3&nbsp;Configuration 3: Sort-Last Rendering (Object-Space Decomposition)</h2>

<div class="figure">
<img src="chromium-sortlast.png" alt="chromium-sortlast" class="figure" id="imgid_23" name="imgid_23"/>
</div>

<p>Sort-Last Rendering is used when the scene contains a huge number of
polygons and the rendering bottleneck is processing all of that geometry
on a single graphics card.  In this case, each node runs a separate
copy of the application, and for best results, the application needs
to be at least partly aware that it&rsquo;s running in a parallel environment
so that it can give Chromium hints as to how to distribute the various
objects to be rendered.  Each node generates an image of a particular
portion of the object space, and these images must be composited in
such a way that the front-to-back ordering of pixels is maintained.
This is generally done by collecting Z buffer data from each node to
determine whether a particular pixel on a particular node is visible
in the final image.  The rendered images from each node are often composited
using a &ldquo;binary swap&rdquo;, whereby the nodes combine their
images in a cascading tree so that the overall compositing time is
proportional to log<sub>2</sub>(N) rather than N.</p>

<p>To make this configuration work with VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Start the mothership on Node 0 with an appropriate configuration for
        performing sort-last rendering
    </li>
    <li class="Ordered">
        Start <code>crappfaker</code> on each of the rendering nodes
    </li>
    <li class="Ordered">
        On Node 0, set <code>CR_SYSTEM_GL_PATH</code> to the appropriate value
        for the operating system and application type (see table in Section
        <a href="#CR_SYSTEM_GL_PATH_Table" class="ref">14.2</a>.)
    </li>
    <li class="Ordered">
        On Node 0, <code>vglrun&nbsp;crserver</code>
    </li>
</ol>


<h3 id="hd0014003001">CRUT</h3>

<p>The Chromium Utility Toolkit provides a convenient way for graphics
applications to specifically take advantage of Chromium&rsquo;s sort-last
rendering capabilities.  Such applications can use CRUT to explicitly
specify how their object space should be decomposed.  CRUT applications
require an additional piece of software, <code>crutserver</code>, to
be running on Node 0.  So to make such applications work with VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Start the mothership on Node 0 with an appropriate configuration for
        performing sort-last rendering
    </li>
    <li class="Ordered">
        Start <code>crappfaker</code> on each of the rendering nodes
    </li>
    <li class="Ordered">
        On Node 0, set <code>CR_SYSTEM_GL_PATH</code> to the appropriate value
        for the operating system and application type (see table in Section
        <a href="#CR_SYSTEM_GL_PATH_Table" class="ref">14.2</a>.)
    </li>
    <li class="Ordered">
        On Node 0, <code>vglrun&nbsp;crutserver&nbsp;&amp;</code>
    </li>
    <li class="Ordered">
        On Node 0, <code>vglrun&nbsp;crserver</code>
    </li>
</ol>


<h2 id="hd0014004">14.4&nbsp;A Note About Performance</h2>

<p>Chromium&rsquo;s use of X11 is generally not very optimal.  It assumes
a very fast connection between the X server and the Chromium Server.
In certain modes, Chromium polls the X server on every frame to determine
whether windows have been resized, etc.  Thus, we have observed that,
even on a fast network, Chromium tends to perform much better with
VirtualGL running in a TurboVNC session as opposed to using the VGL
Image Transport.</p>


<h2 id="hd0014005">14.5&nbsp;ModViz VGP and VirtualGL</h2>

<p>ModViz Virtual Graphics Platform<sup>TM</sup> is a polished commercial
clustered rendering framework for Linux which supports all three of
the rendering modes described above and provides a much more straightforward
interface to configure and run these types of parallel rendering jobs.</p>

<p>All VGP jobs, regardless of configuration, are all spawned through
<code>vglauncher</code>, a front-end program which automatically takes
care of starting the appropriate processes on the rendering nodes,
intercepting OpenGL calls from the application instance(s), sending
rendered images back to Node 0, and compositing the images as appropriate.
In a similar manner to VirtualGL&rsquo;s <code>vglrun</code>, VGP&rsquo;s
vglauncher preloads a library (<code>libVGP.so</code>) in place of
<code>libGL.so</code>, and this library intercepts the OpenGL calls
from the application.</p>

<p>So our strategy here is similar to our strategy for loading the Chromium
App Faker.  We want to insert VirtualGL between VGP and the real system
OpenGL library, so that VGP will call VirtualGL and VirtualGL will
call <code>libGL.so</code>. Achieving this with VGP is relatively simple:</p>

<pre class="verbatim">
export&nbsp;VGP_BACKING_GL_LIB=librrfaker.so
vglrun&nbsp;vglauncher&nbsp;--preload=librrfaker.so:/usr/lib/libGL.so&nbsp;{application}
</pre>

<p>Replace <code>/usr/lib/libGL.so</code> with the full path of your system&rsquo;s
OpenGL library (<code>/usr/lib64/libGL.so</code> if you are launching
a 64-bit application.)</p>

<hr class="break" />


<h1 id="hd0015"><a name="file015"></a>15&nbsp;Other Application Recipes</h1>

<p><a name="Application_Recipes"></a></p>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">Application</th>
    <th class="head standard">Platform</th>
    <th class="head standard">Recipe</th>
    <th class="head standard">Notes</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard">ANSA v12.1.0</td>
    <td class="standard">Linux/x86</td>
    <td class="standard">Add <br /><br /> <code>LD_PRELOAD_SAVE=$LD_PRELOAD</code><br /> <code>export&nbsp;LD_PRELOAD=</code> <br /><br /> to the top of the <code>ansa.sh</code> script, then add <br /><br /> <code>export&nbsp;LD_PRELOAD=$LD_PRELOAD_SAVE</code> <br /><br /> just prior to the <code>${ANSA_EXEC_DIR}bin/ansa_linux${ext2}</code> line.</td>
    <td class="standard">The ANSA startup script directly invokes <code>/lib/libc.so.6</code> to query the glibc version.  Since the VirtualGL faker depends on libc, preloading VirtualGL when directly invoking <code>libc.so.6</code> creates an infinite loop. So it is necessary to disable the preloading of VirtualGL in the application script and then re-enable it prior to launching the actual application.</td>
  </tr>
  <tr class="standard">
    <td class="standard">ANSYS v11.0</td>
    <td class="standard">All</td>
    <td class="standard">If you experience extremely long delays (on the order of minutes) when reading input data or performing other operations in ANSYS: <br /><br /> If using the VGL Image Transport, set the environment variable <code>VGL_INTERFRAME</code> to <code>0</code> on the VirtualGL server prior to launching ANSYS.  When running ANSYS in a TurboVNC session on the VirtualGL server, set the environment variable <code>VGL_FPS</code> to <code>20</code> prior to launching ANSYS.</td>
    <td class="standard">See <a href="#ansys_proe">notes</a><a name="idx0086"></a> below</td>
  </tr>
  <tr class="standard">
    <td class="standard">Army Ops</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;-dl&nbsp;armyops</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">AutoForm v4.0x</td>
    <td class="standard">All</td>
    <td class="standard"><code>vglrun&nbsp;+sync&nbsp;xaf_</code><em><code>{version}</code></em></td>
    <td class="standard">AutoForm relies on mixed X11/OpenGL rendering, and thus certain features (particularly the &ldquo;Dynamic Section&rdquo; dialog and &ldquo;Export Image&rdquo; feature) do not work properly unless <code>VGL_SYNC</code> is enabled.  Since <code>VGL_SYNC</code> automatically enables the X11 image transport and disables frame spoiling, it is highly recommended that you use TurboVNC when <code>VGL_SYNC</code> is enabled.  See Section <a href="#VGL_SYNC" class="ref">19.1</a> for more details.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Cedega v6.0.x</td>
    <td class="standard">Linux</td>
    <td class="standard">Add <br /><br /> <code>export&nbsp;LD_PRELOAD=librrfaker.so</code> <br /><br /> to the top of <code>~/.cedega/.winex_ver/winex-{version}/bin/winex3</code>, then run Cedega as you would normally (without <code>vglrun</code>.)  Since <code>vglrun</code> is not being used, it is necessary to use environment variables or the VirtualGL Configuration dialog to modify VirtualGL&rsquo;s configuration.</td>
    <td class="standard">The actual binary (WineX) which uses OpenGL is buried beneath several layers of Python and shell scripts.  The <code>LD_PRELOAD</code> variable does not get propagated down from the initial shell that invoked <code>vglrun</code>.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Descent 3</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;descent3&nbsp;-g&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;descent3</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Doom 3</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;doom3&nbsp;+set&nbsp;r_glDriver&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;doom3</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Enemy Territory (Return to Castle Wolfenstein)</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;et&nbsp;+set&nbsp;r_glDriver&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;et</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Heretic II</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;heretic2&nbsp;+set&nbsp;gl_driver&nbsp;/usr/lib/librrfaker.so&nbsp;+set&nbsp;vid_ref&nbsp;glx</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;heretic2&nbsp;+set&nbsp;vid_ref&nbsp;glx</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Heavy Gear II</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;hg2&nbsp;-o&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;hg2</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">HyperWorks v8 (Altair)</td>
    <td class="standard">Linux/x86-64</td>
    <td class="standard"><code>vglrun&nbsp;-dl&nbsp;</code><em><code>{application&nbsp;script}</code></em></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details.</td>
  </tr>
  <tr class="standard">
    <td class="standard">I-deas Master Series 9, 10, &amp; 11</td>
    <td class="standard">Solaris/Sparc</td>
    <td class="standard">When running I-deas with VirtualGL on a Solaris/Sparc server, remotely displaying to a non-Sparc client machine or to an X proxy such as VNC, it may be necessary to set the <code>SDRC_SUN_IGNORE_GAMMA</code> environment variable to <code>1</code>.</td>
    <td class="standard">I-deas normally aborts if it detects that the X visual assigned to it is not gamma-corrected.  But gamma-corrected X visuals only exist on Solaris/Sparc X servers, so if you are displaying the application to another type of X server or X proxy which doesn&rsquo;t provide gamma-corrected X visuals, then it is necessary to override the gamma detection mechanism in I-deas.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Java2D applications that use OpenGL</td>
    <td class="standard">Linux, Solaris</td>
    <td class="standard">Java2D will use OpenGL to perform its rendering if <code>sun.java2d.opengl</code> is set to <code>True</code>.  For example: <br /><br /> <code>java&nbsp;-Dsun.java2d.opengl=True&nbsp;MyAppClass</code> <br /><br /> In order for this to work in VirtualGL, it is necessary to invoke <code>vglrun</code> with the <code>-dl</code> switch.  For example: <br /><br /> <code>vglrun&nbsp;-dl&nbsp;java&nbsp;-Dsun.java2d.opengl=True&nbsp;MyAppClass</code> <br /><br /> If you are using Java v6 b92 or later, you can also set the environment variable <code>J2D_ALT_LIBGL_PATH</code> to the path of <code>librrfaker.so</code>.  For example: <br /><br /> <code>setenv&nbsp;J2D_ALT_LIBGL_PATH&nbsp;/opt/VirtualGL/lib/librrfaker.so</code><br /> <code>vglrun&nbsp;java&nbsp;-Dsun.java2d.opengl=True&nbsp;MyAppClass</code> <br /><br /></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Java2D applications that use OpenGL</td>
    <td class="standard">Solaris/Sparc</td>
    <td class="standard">When VirtualGL is used in conjunction with Java v5.0 (also known as Java 1.5.0) to remotely display Java2D applications using the OpenGL pipeline (see above), certain Java2D applications will cause the OpenGL subsystem to crash with the following error: <br /><br /> <code>thread&nbsp;tries&nbsp;to&nbsp;access&nbsp;GL&nbsp;context&nbsp;current&nbsp;to&nbsp;another&nbsp;thread</code> <br /><br /> If you encounter this error, try setting the <code>SUN_OGL_IS_MT</code> environment variable to <code>1</code> and re-running the application.</td>
    <td class="standard">Java 5.0 should call <code>glXInitThreadsSUN()</code> since it is using multiple OpenGL threads, but it doesn&rsquo;t.  Purely by chance, this doesn&rsquo;t cause any problems when the application is displayed locally.  But VirtualGL changes things up enough that the luck runs out.  This issue does not exist in Java 6.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Pro/ENGINEER Wildfire v2.0</td>
    <td class="standard">Solaris/Sparc</td>
    <td class="standard">Add <br /><br /> <code>graphics&nbsp;opengl</code> <br /><br /> to <code>~/config.pro</code>.  You may also need to set the <code>VGL_XVENDOR</code> environment variable to <code>&quot;Sun&nbsp;Microsystems,&nbsp;Inc.&quot;</code> if you are running Pro/ENGINEER 2.0 over a remote X connection to a Linux or Windows VirtualGL client.</td>
    <td class="standard">Pro/E 2.0 for Solaris will disable OpenGL if it detects a remote connection to a non-Sun X server.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Pro/ENGINEER Wildfire v3.0</td>
    <td class="standard">All</td>
    <td class="standard">If you experience extremely long delays (on the order of minutes) when zooming or performing other operations in Pro/E: <br /><br /> If using the VGL Image Transport, set the environment variable <code>VGL_INTERFRAME</code> to <code>0</code> on the VirtualGL server prior to launching Pro/E.  When running Pro/E in a TurboVNC session on the VirtualGL server, set the environment variable <code>VGL_FPS</code> to <code>20</code> prior to launching Pro/E.</td>
    <td class="standard">See <a href="#ansys_proe">notes</a><a name="idx0087"></a> below</td>
  </tr>
  <tr class="standard">
    <td class="standard">QGL (OpenGL Qt Widget)</td>
    <td class="standard">Linux</td>
    <td class="standard"><code>vglrun&nbsp;-dl&nbsp;{application}</code></td>
    <td class="standard">Qt can be built such that it either resolves symbols from libGL automatically or uses <code>dlopen()</code> to manually resolve those symbols from libGL.  As of Qt v3.3, the latter behavior is the default, so OpenGL programs built with later versions of libQt will not work with VirtualGL unless the <code>-dl</code> switch is used with <code>vglrun</code>. <br /><br /> See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Quake 3</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;quake3&nbsp;+set&nbsp;r_glDriver&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;quake3</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Soldier of Fortune</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;sof&nbsp;+set&nbsp;gl_driver&nbsp;/usr/lib/librrfaker.so</code> <br /><br /> or <br /><br /> <code>vglrun&nbsp;-dl&nbsp;sof</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Unreal Tournament 2004</td>
    <td class="standard">Linux/x86</td>
    <td class="standard"><code>vglrun&nbsp;-dl&nbsp;ut2004</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
  <tr class="standard">
    <td class="standard">Wine</td>
    <td class="standard">Linux</td>
    <td class="standard"><code>vglrun&nbsp;-dl&nbsp;wine&nbsp;{windows_opengl_app.exe}</code></td>
    <td class="standard">See Chapter <a href="#dlopen" class="ref">13</a> for more details</td>
  </tr>
</table>
</div>



<h3 id="hd0015000001">Notes for ANSYS and Pro/E</h3>

<p><a name="ansys_proe"></a></p>

<p>ANSYS and Pro/E frequently render to the front buffer and, for unknown
reasons, call <code>glFlush()</code> thousands of times in a row even
if nothing new has been rendered.  This exposes a vulnerability in
VirtualGL&rsquo;s framebuffer readback heuristics.  Normally, when
an application calls <code>glFlush()</code> on the front buffer, VirtualGL
will read back, compress, and send the pixels from the front buffer.
But if <code>glFlush()</code> is called thousands of times without
changing the contents of the frame buffer, this causes VirtualGL to
read back, compress, and send thousands of duplicate images.  Whereas
calling <code>glFlush()</code> on a local display takes practically
no time, reading back and sending an image in VirtualGL takes a relatively
long amount of time.  So, left unchecked, this phenomenon can lead
to delays of several minutes when performing certain operations in
ANSYS and Pro/E while using VirtualGL.</p>

<p>If frame spoiling is enabled, then VirtualGL will not read back the
framebuffer in response to a <code>glFlush()</code> call if a prior
image is still being compressed/sent.  Ideally, this would cause most
of the duplicate <code>glFlush()</code> calls to be ignored by VirtualGL.
However, this frame spoiling algorithm only works if it takes longer
to compress and send an image than it does to read it back from the
framebuffer.  Frames are spoiled during the time that the readback
thread is waiting for the compressor thread to finish with the previous
frame, so if the readback thread never has to wait on the compressor
thread, then no frames are ever spoiled.  There are several reasons
why this could occur:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        The system contains an old, slow bus (AGP, for instance) and thus the
        readback performance from the graphics card is relatively slow.
    </li>
    <li class="Ordered">
        TurboVNC is being used on the same server as VirtualGL.  If this is
        the case, then the compressor thread is passing images to TurboVNC
        through shared memory, which (even on modern systems) is almost always
        faster than reading back images from the graphics card.
    </li>
    <li class="Ordered">
        Interframe comparison is enabled in the VGL Image Transport.  In the
        case of ANSYS and Pro/E, each duplicate frame can be compared and discarded
        by the compressor much more quickly than it can be read back from the
        graphics card, so no spoiling occurs.
    </li>
</ol>

<p>A more robust fix for this problem is slated for the next release of
VirtualGL, but for now, it is necessary to work around the issue if
it occurs.  The workaround is essentially to slow the compressor thread
down such that it is slower than the readback thread.  When using the
VGL Image Transport, it is usually only necessary to disable interframe
comparison (<code>VGL_INTERFRAME=0</code>) to accomplish this.  But
when using the X11 Image Transport and TurboVNC, it is necessary to
introduce an artificial delay into the compressor thread by setting
<code>VGL_FPS</code>.  A value of <code>20</code> for <code>VGL_FPS</code>
is a reasonable starting point, but you may have to decrease this value
if the readback performance on your system is exceptionally slow.</p>

<hr class="break" />


<h1 id="hd0016"><a name="file016"></a>16&nbsp;Advanced OpenGL Features</h1>

<p><a name="Advanced_OpenGL"></a></p>


<h2 id="hd0016001">16.1&nbsp;Stereographic Rendering</h2>

<p>Stereographic rendering is a feature of OpenGL that creates separate
rendering buffers for the left and right eyes and allows the application
to render a different image into each buffer.  How the stereo images
are subsequently displayed depends on the particulars of the 3D hardware
and the user&rsquo;s environment.  VirtualGL can support stereographic
applications in one of two ways: (1) by sending the stereo image pairs
to the client to be displayed in stereo by the client&rsquo;s 3D graphics
card, or (2) by combining each stereo image pair into a single anaglyph
that can be viewed with traditional red/cyan 3D glasses.</p>


<h3 id="hd0016001001">16.1.1&nbsp;Quad-Buffered Stereo</h3>

<p>The name &ldquo;quad-buffered&rdquo; stereo derives from the fact that
OpenGL uses four buffers (left front, right front, left back, and right
back) to support stereographic rendering with double buffering.  3D
graphics cards with quad-buffered stereo capabilities generally provide
some sort of synchronization signal that can be used to control various
types of active stereo 3D glasses.  Some also support &ldquo;passive
stereo&rdquo;, which displays the left and right eye buffers to different
monitor outputs.  VirtualGL supports true quad-buffered stereo by rendering
the stereo images on the server and sending the image pairs across
the network to be displayed by a 3D graphics card on the client.</p>

<p>In most cases, the VirtualGL and TurboVNC clients use only 2D drawing
commands, thus eliminating the need for a 3D graphics card on the client
machine.  But drawing stereo images requires a 3D graphics card, so
such a card must be present in any client machine that will use VirtualGL&rsquo;s
quad-buffered stereo mode.  Since the 3D graphics card is only being
used to draw images, it need not necessarily be a high-end card.  Generally,
the least expensive 3D graphics card that has stereo capabilities will
work fine in a VirtualGL client.</p>

<p>The server must also have a 3D graphics card that supports stereo,
since this is the only way that VirtualGL can obtain a stereo Pbuffer.
When an application tries to render something in stereo, VirtualGL
will (by default) use quad-buffered stereo rendering if:</p>

<ul class="Itemize">
    <li class="Itemize asterisk">
        The client supports OpenGL (Exceed 3D is required for Windows clients)
    </li>
    <li class="Itemize asterisk">
        The client has stereo rendering capabilities
    </li>
    <li class="Itemize asterisk">
        The server has stereo rendering capabilities
    </li>
</ul>

<p>If one or more of these is not true, then VirtualGL will fall back
to using anaglyphic stereo (see below.)  It is usually necessary to
explicitly enable stereo in the graphics driver configuration for both
the client and server machines.  The
<a href="#Troubleshooting">Troubleshooting</a><a name="idx0088"></a>
section below lists a way to verify that both client and server have
stereo visuals available.</p>

<p>In quad-buffered mode, VirtualGL reads back both eye buffers on the
server and sends the contents as a pair of compressed images (one for
each eye) to the VirtualGL Client.  The VirtualGL Client then decompresses
both images and draws them as a single stereo frame to the client machine&rsquo;s
X display using <code>glDrawPixels()</code>.  It should thus be no
surprise that enabling quad-buffered stereo in VirtualGL decreases
performance by 50% or more and uses twice the network bandwidth to
maintain the same frame rate.</p>

<p>Quad-buffered stereo requires the VGL Image Transport.  If any other
image transport is used, then VGL will fall back to anaglyphic stereo
mode.</p>


<h3 id="hd0016001002">16.1.2&nbsp;Anaglyphic Stereo</h3>

<p>Anaglyphic stereo is the type of stereographic display used by old
3D movies. It generally relies on a set of 3D glasses consisting of
red transparency film over the left eye and cyan transparency film
over the right eye.  To generate a 3D anaglyph, the red color data
from the left eye buffer is combined with the green and blue color
data from the right eye buffer, thus allowing a single monographic
image to contain stereo data.  From the point of view of VirtualGL,
an anaglyphic image is the same as a monographic image, so anaglyphic
stereo images can be sent using any image transport to any type of
client, regardless of the client&rsquo;s capabilities.</p>

<p>VirtualGL uses anaglyphic stereo if it detects that an application
has rendered something in stereo but quad-buffered stereo is not available,
either because the client doesn&rsquo;t support it or because a transport
other than the VGL Image Transport is being used.  Anaglyphic stereo
provides a cheap and easy way to view stereographic applications in
X proxies and on clients that do not support quad-buffered stereo.
Additionally, anaglyphic stereo performs much faster than quad-buffered
stereo, since it does not require sending twice the data to the client.</p>

<p>As with quad-buffered stereo, anaglyphic stereo requires that the server
have stereo rendering capabilities.  However, anaglyphic stereo does
not require any 3D rendering capabilities (stereo or otherwise) on
the client.</p>


<h3 id="hd0016001003">16.1.3&nbsp;Selecting a Stereo Mode</h3>

<p>A particular stereo mode can be selected by setting the <code>VGL_STEREO</code>
environment variable or by using the <code>-st</code> argument to <code>vglrun</code>.
See Section <a href="#VGL_STEREO" class="ref">19.1</a> for more details.</p>


<h2 id="hd0016002">16.2&nbsp;Transparent Overlays</h2>

<p>Transparent overlays have similar requirements and restrictions as
quad-buffered stereo.  In this case, VirtualGL completely bypasses
its own GLX faker and uses indirect OpenGL rendering to render the
transparent overlay on the client machine&rsquo;s 3D graphics card.
The underlay is still rendered on the server, as always.  Using indirect
rendering to render the overlay is unfortunately necessary, because
there is no reliable way to draw to an overlay using 2D (X11) functions,
there are severe performance issues (on some cards) with using <code>glDrawPixels()</code>
to draw to the overlay, and there is no reasonable way to composite
the overlay and underlay on the VirtualGL server.</p>

<p>The use of overlays is becoming more and more infrequent, and when
they are used, it is generally only for drawing small, simple, static
shapes and text. We have found that it is often faster to send the
overlay geometry over to the client rather than to render it as an
image and send the image.  So even if it were possible to implement
overlays without using indirect rendering, it&rsquo;s likely that indirect
rendering of overlays would still be the fastest approach for most
applications.</p>

<p>As with stereo, overlays must sometimes be explicitly enabled in the
graphics card&rsquo;s configuration.  In the case of overlays, however,
they need only be supported and enabled on the client machine.</p>

<p>Indexed color (8-bit) overlays have been tested and are known to work
with VirtualGL.  True color (24-bit) overlays work, in theory, but
have not been tested.  Use <code>glxinfo</code> (see
<a href="#Troubleshooting">Troubleshooting</a><a name="idx0089"></a>
below) to verify whether your client&rsquo;s X display supports overlays
and whether they are enabled.  In Exceed 3D, make sure that the &ldquo;Overlay
Support&rdquo; option is checked in the &ldquo;Exceed 3D and GLX&rdquo;
applet:</p>

<p><img src="exceed6.png" alt="exceed6" class="inline" id="imgid_8" name="imgid_8"/></p>

<div class="important"><p class="important">
Overlays do not work with X proxies (including TurboVNC.)  VirtualGL must be displaying to a &ldquo;real&rdquo; X server.
</p></div>


<h2 id="hd0016003">16.3&nbsp;Indexed (PseudoColor) Rendering</h2>

<p>In a PseudoColor visual, each pixel is represented by an index which
refers to a location in a color table.  The color table stores the
actual color values (256 of them in the case of 8-bit PseudoColor)
which correspond to each index. An application merely tells the X server
which color index to use when drawing, and the X server takes care
of mapping that index to an actual color from the color table.  OpenGL
allows for rendering to Pseudocolor visuals, and it does so by being
intentionally ignorant of the relationship between indices and actual
colors.  As far as OpenGL is concerned, each color index value is just
a meaningless number, and it is only when the final image is drawn
by the X server that these numbers take on meaning.  As a result, many
pieces of OpenGL&rsquo;s core functionality either have undefined behavior
or do not work at all with PseudoColor rendering.  PseudoColor rendering
used to be a common technique to visualize scientific data, because
such data often only contained 8 bits per sample to begin with.  Applications
could manipulate the color table to allow the user to dynamically control
the relationship between sample values and colors.  As more and more
graphics cards drop support for PseudoColor rendering, however, the
applications which use it are becoming a vanishing breed.</p>

<p>VirtualGL supports PseudoColor rendering if a PseudoColor visual is
available on the client&rsquo;s display.  A PseudoColor visual need
not be present on the server.  On the server, VirtualGL uses the red
channel of a standard RGB Pbuffer to store the color index.  Upon receiving
an end of frame trigger, VirtualGL reads back the red channel of the
Pbuffer and uses <code>XPutImage()</code> to draw the color indices
into the appropriate X window.  To put this another way, PseudoColor
rendering in VirtualGL always uses the X11 Image Transport. However,
since there is only 1 byte per pixel in a PseudoColor &ldquo;image&rdquo;,
the images can still be sent to the client reasonably quickly even
though they are uncompressed.</p>

<p>VirtualGL&rsquo;s PseudoColor rendering support works with VNC, provided
that the VNC server is configured with an 8-bit color depth.  TurboVNC
does not support 8-bit color depths, but RealVNC and other VNC flavors
do.  Note, however, that VNC cannot provide both PseudoColor and TrueColor
visuals at the same time.</p>


<h2 id="hd0016004">16.4&nbsp;Troubleshooting</h2>

<p><a name="Troubleshooting"></a></p>

<p>VirtualGL includes a modified version of <code>glxinfo</code> that
can be used to determine whether or not the client and server have
stereo, overlay, or Pseudocolor visuals enabled.</p>

<p>Run one of the following command sequences on the VirtualGL server
to determine whether the server has a suitable visual for stereographic
rendering:</p>

<dl class="Description">
    <dt class="Description">Solaris servers (using GLP)</dt>
    <dd class="Description">
<pre class="verbatim">
/opt/VirtualGL/bin/glxinfo&nbsp;-d&nbsp;{glp_device}&nbsp;-v
</pre>

    </dd>
    <dt class="Description">Linux and Solaris servers (not using GLP)</dt>
    <dd class="Description">
<pre class="verbatim">
xauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key
/opt/VirtualGL/bin/glxinfo&nbsp;-display&nbsp;:0&nbsp;-c&nbsp;-v
</pre>

    </dd>
</dl>

<p>One or more of the visuals should say &ldquo;stereo=1&rdquo; and should
list &ldquo;Pbuffer&rdquo; as one of the &ldquo;Drawable Types.&rdquo;</p>

<p>Run the following command sequence on the VirtualGL server to determine
whether the X display on the client has a suitable visual for stereographic
rendering, transparent overlays, or Pseudocolor.</p>

<pre class="verbatim">
/opt/VirtualGL/bin/glxinfo&nbsp;-v
</pre>

<p>In order to use stereo, one or more of the visuals should say &ldquo;stereo=1&rdquo;.
In order to use transparent overlays, one or more of the visuals should
say &ldquo;level=1&rdquo;, should list a &ldquo;Transparent Index&rdquo;
(non-transparent visuals will say &ldquo;Opaque&rdquo; instead), and
should have a class of &ldquo;PseudoColor.&rdquo;  In order to use
PseudoColor (indexed) rendering, one of the visuals should have a class
of &ldquo;PseudoColor.&rdquo;</p>

<hr class="break" />


<h1 id="hd0017"><a name="file017"></a>17&nbsp;Performance Measurement</h1>

<p><a name="Perf_Measurement"></a></p>


<h2 id="hd0017001">17.1&nbsp;VirtualGL&rsquo;s Built-In Profiling System</h2>

<p>The easiest way to uncover bottlenecks in VirtualGL&rsquo;s image pipelines
is to set the <code>VGL_PROFILE</code> environment variable to <code>1</code>
on both server and client (passing an argument of <code>+pr</code>
to <code>vglrun</code> on the server has the same effect.)  This will
cause VirtualGL to measure and report the throughput of the various
stages in the pipeline.  For example, here are some measurements from
a dual Pentium 4 server communicating with a Pentium III client on
a 100 Megabit LAN:</p>

<dl class="Description">
    <dt class="Description">Server</dt>
    <dd class="Description">
<pre class="verbatim">
Readback&nbsp;&nbsp;&nbsp;-&nbsp;43.27&nbsp;Mpixels/sec&nbsp;-&nbsp;34.60&nbsp;fps
Compress&nbsp;0&nbsp;-&nbsp;33.56&nbsp;Mpixels/sec&nbsp;-&nbsp;26.84&nbsp;fps
Total&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;8.02&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;6.41&nbsp;fps&nbsp;-&nbsp;10.19&nbsp;Mbits/sec&nbsp;(18.9:1)
</pre>

    </dd>
    <dt class="Description">Client</dt>
    <dd class="Description">
<pre class="verbatim">
Decompress&nbsp;-&nbsp;10.35&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;8.28&nbsp;fps
Blit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;35.75&nbsp;Mpixels/sec&nbsp;-&nbsp;28.59&nbsp;fps
Total&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;8.00&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;6.40&nbsp;fps&nbsp;-&nbsp;10.18&nbsp;Mbits/sec&nbsp;(18.9:1)
</pre>

    </dd>
</dl>

<p>The total throughput of the pipeline is 8.0 Megapixels/sec, or 6.4
frames/sec, indicating that our frame is 8.0 / 6.4 = 1.25 Megapixels
in size (a little less than 1280 x 1024 pixels.)  The readback and
compress stages, which occur in parallel on the server, are obviously
not slowing things down.  And we&rsquo;re only using 1/10 of our available
network bandwidth.  So we look to the client and discover that its
slow decompression speed (10.35 Megapixels/second) is the primary bottleneck.
Decompression and blitting on the client cannot be done in parallel,
so the aggregate performance is the harmonic mean of the decompression
and blitting rates:  <em>[1/ (1/10.35 + 1/35.75)] = 8.0 Mpixels/sec</em>.</p>


<h2 id="hd0017002">17.2&nbsp;Frame Spoiling</h2>

<p><a name="Frame_Spoiling"></a></p>

<p>By default, VirtualGL will only send a frame to the client if the client
is ready to receive it.  If a rendered frame arrives at the server&rsquo;s
queue and there are frames waiting in the queue to be processed, then
those unprocessed frames are dropped (&ldquo;spoiled&rdquo;) and the
new frame is promoted to the head of the queue.  This prevents a backlog
of frames on the server, which would cause a perceptible delay in the
responsiveness of interactive applications.  However, when running
non-interactive applications, particularly benchmarks, frame spoiling
should always be disabled.   With frame spoiling disabled, the server
will render frames only as quickly as VirtualGL can send those frames
to the client, which will conserve server resources as well as allow
OpenGL benchmarks to accurately measure the frame rate of the VirtualGL
system.  With frame spoiling enabled, OpenGL benchmarks will report
meaningless data, since the rate at which the server can render frames
is decoupled from the rate at which VirtualGL can send those frames
to the client.</p>

<p>In a VNC environment, there is another layer of frame spoiling, since
the server only sends updates to the client when the client requests
them.  So even if frame spoiling is disabled in VirtualGL, OpenGL benchmarks
will still report meaningless data if they are run in a VNC session.
TCBench, described below, provides a limited solution to this problem.</p>

<p>To disable frame spoiling, set the <code>VGL_SPOIL</code> environment
variable to <code>0</code> on the server or pass an argument of <code>-sp</code>
to <code>vglrun</code>.  See Section <a href="#VGL_SPOIL" class="ref">19.1</a>
for more details.</p>


<h2 id="hd0017003">17.3&nbsp;VirtualGL Diagnostic Tools</h2>

<p>VirtualGL includes several tools which can be useful in diagnosing
performance problems with the system.</p>


<h3 id="hd0017003001">NetTest</h3>

<p>NetTest is a network benchmark that uses the same network I/O classes
as VirtualGL.  It can be used to test the latency and throughput of
any TCP/IP connection, with or without SSL encryption.  <code>nettest</code>
can be found in <code>/opt/VirtualGL/bin</code> on Linux/Mac/Solaris
VirtualGL installations or in <code>c:\program&nbsp;files\VirtualGL-{version}-{build}</code>
on Windows installations.</p>

<p>To use NetTest, first start up the nettest server on one end of the
connection:</p>

<pre class="verbatim">
nettest&nbsp;-server&nbsp;[-ssl]
</pre>

<p>(use <code>-ssl</code> if you want to test the performance of SSL encryption
over this particular connection.)</p>

<p>Next, start the client on the other end of the connection:</p>

<pre class="verbatim">
nettest&nbsp;-client&nbsp;{server}&nbsp;[-ssl]
</pre>

<p>Replace <em><code>{server}</code></em> with the hostname or IP address
of the machine where the NetTest server is running.  Use <code>-ssl</code>
if the NetTest server is running in SSL mode.)</p>

<p>The nettest client will produce output similar to the following:</p>

<pre class="verbatim">
TCP&nbsp;transfer&nbsp;performance&nbsp;between&nbsp;localhost&nbsp;and&nbsp;{server}:

Transfer&nbsp;size&nbsp;&nbsp;1/2&nbsp;Round-Trip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throughput&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throughput
(bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(msec)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MB/sec)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Mbits/sec)
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.093402&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.010210&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.085651
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.087308&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.021846&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.183259
4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.087504&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.043594&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.365697
8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.088105&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.086595&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.726409
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.090090&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.169373&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.420804
32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.093893&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.325026&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.726514
64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.102289&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.596693&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.005424
128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.118493&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.030190&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.641863
256&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.146603&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.665318&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.969704
512&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.205092&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.380790&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19.971514
1024&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.325896&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.996542&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25.136815
2048&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.476611&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.097946&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;34.376065
4096&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.639502&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.108265&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;51.239840
8192&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.033596&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.558565&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;63.405839
16384&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.706110&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.158259&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;76.825049
32768&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.089896&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.113608&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;84.839091
65536&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.909509&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.576174&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;88.719379
131072&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.453894&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.913319&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;91.547558
262144&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22.616389&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.053931&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;92.727094
524288&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;44.882406&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.140223&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;93.450962
1048576&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;89.440702&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.180592&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;93.789603
2097152&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;178.536997&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.202160&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;93.970529
4194304&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;356.754396&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.212195&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;94.054712
</pre>

<p>We can see that the throughput peaks at about 94 megabits/sec, which
is pretty good for a 100 Megabit connection.  We can also see that,
for small transfer sizes, the round-trip time is dominated by latency.
The &ldquo;latency&rdquo; is the same thing as the 1/2 round-trip time
for a zero-byte packet, which is about 93 microseconds in this case.</p>


<h3 id="hd0017003002">CPUstat</h3>

<p>CPUstat is available only in the VirtualGL Linux packages and is located
in the same place as NetTest (<code>/opt/VirtualGL/bin</code>.)  It
measures the average, minimum, and peak CPU usage for all processors
combined and for each processor individually.  On Windows, this same
functionality is provided in the Windows Performance Monitor, which
is part of the operating system.  On Solaris, the same data can be
obtained through <code>vmstat</code>.</p>

<p>CPUstat measures the CPU usage over a given sample period (a few seconds)
and continuously reports how much the CPU was utilized since the last
sample period.  Output for a particular sample looks something like
this:</p>

<pre class="verbatim">
ALL&nbsp;:&nbsp;&nbsp;51.0&nbsp;(Usr=&nbsp;47.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;3.5)&nbsp;/&nbsp;Min=&nbsp;47.4&nbsp;Max=&nbsp;52.8&nbsp;Avg=&nbsp;50.8
cpu0:&nbsp;&nbsp;20.5&nbsp;(Usr=&nbsp;19.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;1.0)&nbsp;/&nbsp;Min=&nbsp;19.4&nbsp;Max=&nbsp;88.6&nbsp;Avg=&nbsp;45.7
cpu1:&nbsp;&nbsp;81.5&nbsp;(Usr=&nbsp;75.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;6.0)&nbsp;/&nbsp;Min=&nbsp;16.6&nbsp;Max=&nbsp;83.5&nbsp;Avg=&nbsp;56.3
</pre>

<p>The first column indicates what percentage of time the CPU was active
since the last sample period (this is then broken down into what percentage
of time the CPU spent running user, nice, and system/kernel code.)
&ldquo;ALL&rdquo; indicates the average utilization across all CPUs
since the last sample period.  &ldquo;Min&rdquo;, &ldquo;Max&rdquo;,
and &ldquo;Avg&rdquo; indicate a running minimum, maximum, and average
of all samples since cpustat was started.</p>

<p>Generally, if an application&rsquo;s CPU usage is fairly steady, you
can run CPUstat for a bit and wait for the Max. and Avg. for the &ldquo;ALL&rdquo;
category to stabilize, then that will tell you what the application&rsquo;s
peak and average % CPU utilization is.</p>


<h3 id="hd0017003003">TCBench</h3>

<p>TCBench was born out of the need to compare VirtualGL&rsquo;s performance
to that of other thin client packages, some of which had frame spoiling
features that couldn&rsquo;t be disabled.  TCBench measures the frame
rate of a thin client system as seen from the client&rsquo;s point
of view.  It does this by attaching to one of the client windows and
continuously reading back a small area at the center of the window.
While this may seem to be a somewhat non-rigorous test, experiments
have shown that if care is taken to ensure that the application is
updating the center of the window on every frame (such as in a spin
animation), TCBench can produce quite accurate results.  It has been
sanity checked with VirtualGL&rsquo;s internal profiling mechanism
and with a variety of system-specific techniques, such as monitoring
redraw events on the client&rsquo;s windowing system.</p>

<p>TCBench can be found in <code>/opt/VirtualGL/bin</code> on Linux/Mac/Solaris
or in <code>c:\program&nbsp;files\VirtualGL-{version}-{build}</code>
on Windows.  Run <code>tcbench</code> from the command line, and it
will prompt you to click in the window you want to measure.   That
window should already have an automated animation of some sort running
before you launch TCBench.  Note that GLXSpheres (see below) is an
ideal benchmark to use with TCBench, since GLXSpheres draws a new sphere
to the center of its window on every frame.</p>

<p>TCBench can also be used to measure the frame rate of applications
that are running on the local display, although for extremely fast
applications (those that exceed 40 fps on the local display), you may
need to increase the sampling rate of TCBench to get accurate results.
The default sampling rate of 50 samples/sec should be fine for measuring
the throughput of VirtualGL and other thin client systems.</p>

<pre class="verbatim">
tcbench&nbsp;-?
</pre>

<p>gives the relevant command line switches that can be used to adjust
the benchmark time, the sampling rate, and the x and y offset of the
sampling area within the window.</p>


<h3 id="hd0017003004">GLXSpheres</h3>

<p>GLXSpheres is a benchmark which produces very similar images to NVidia&rsquo;s
(long discontinued) SphereMark benchmark.  Back in the early days of
VirtualGL&rsquo;s existence, it was discovered (quite by accident)
that SphereMark was a pretty good test of VirtualGL&rsquo;s end-to-end
performance, because that benchmark generated images with about the
same amount of solid color and frequency components as the images generated
by volume visualization applications.</p>

<p>Thus, the goal of GLXSpheres was to create an open source Unix version
of SphereMark (the original SphereMark was for Windows only) completely
from scratch.  GLXSpheres does not use any code from the original benchmark,
but it does attempt to mimic the image output of the original as closely
as possible.  GLXSpheres lacks some of the advanced rendering features
of the original, such as the ability to use vertex arrays, but since
it was primarily designed as a benchmark for VirtualGL, display lists
are more than fast enough for that purpose.</p>

<p>GLXSpheres has some additional modes which its predecessor lacked,
modes which are designed specifically to test the performance of various
VirtualGL features:</p>

<dl class="Description">
    <dt class="Description">Stereographic rendering (<code>glxspheres&nbsp;-s</code>)</dt>
    <dd class="Description">
    </dd>
    <dt class="Description">Color index rendering (<code>glxspheres&nbsp;-c</code>)</dt>
    <dd class="Description">
        In color index mode, GLXSpheres will draw the spheres using an 8-bit
        color map and will change the color map periodically.
    </dd>
    <dt class="Description">Overlay rendering (<code>glxspheres&nbsp;-o</code>)</dt>
    <dd class="Description">
        This is similar to color index mode, except that it renders the entire
        scene to a transparent overlay.  This is a somewhat unrealistic test,
        since overlays are normally not used for rendering complex 3D scenes,
        but comparing this mode with color index mode demonstrates the differences
        in how VirtualGL handles overlays and normal PseudoColor rendering.
    </dd>
    <dt class="Description">Immediate mode rendering (<code>glxspheres&nbsp;-m</code>)</dt>
    <dd class="Description">
        Want to really see the benefit of VirtualGL?  Run <code>glxspheres&nbsp;-m</code>
        over a remote X connection, then run <code>vglrun&nbsp;-sp&nbsp;glxspheres&nbsp;-m</code>
        over the same connection and compare. Immediate mode does not use display
        lists, so when immediate mode OpenGL is rendered indirectly (over a
        remote X connection), this causes every OpenGL command to be sent as
        a separate network request to the X server &hellip; on every frame.
        Many applications cannot use display lists, because the geometry they
        are rendering is dynamic, so this models how such applications might
        perform when displayed remotely without VirtualGL.
    </dd>
    <dt class="Description">Interactive mode (<code>glxspheres&nbsp;-i</code>)</dt>
    <dd class="Description">
        In interactive mode, GLXSpheres will wait to draw a frame until it
        receives a mouse event.  Continuously dragging the mouse in the window
        should produce a steady frame rate, and this frame rate is a reasonable
        model of the frame rate that you can achieve when running interactive
        applications in VirtualGL.  Comparing this interactive frame rate (<code>vglrun&nbsp;glxspheres&nbsp;-i</code>)
        with the non-interactive frame rate (<code>vglrun&nbsp;-sp&nbsp;glxspheres</code>)
        allows you to quantify the effect of X latency on the performance of
        interactive applications in a VirtualGL environment.
    </dd>
</dl>

<p>GLXSpheres is installed in <code>/opt/VirtualGL/bin</code> on Linux
and Solaris VirtualGL servers.  64-bit VirtualGL packages contain both
a 32-bit version (<code>glxpheres</code>) and a 64-bit version (<code>glxspheres64</code>.)</p>

<hr class="break" />


<h1 id="hd0018"><a name="file018"></a>18&nbsp;The VirtualGL Configuration Dialog</h1>

<p><a name="Config_Dialog"></a></p>

<p>Several of VirtualGL&rsquo;s configuration parameters can be changed
on the fly once a 3D application has been started.  This is accomplished
by using the VirtualGL Configuration dialog, which can be popped up
by holding down the <code>CTRL</code> and <code>SHIFT</code> keys and
pressing the <code>F9</code> key while any one of the 3D application&rsquo;s
windows is active.  This displays the following dialog box:</p>

<p><img src="configdialog.gif" alt="configdialog" class="inline" id="imgid_9" name="imgid_9"/></p>

<p>You can use this dialog to adjust various image compression and display
parameters in VirtualGL.  Changes are reflected immediately in the
application.</p>

<dl class="Description">
    <dt class="Description">Image Compression (Transport)</dt>
    <dd class="Description">
        This is a drop-down gadget with the following options: <br /><br />
        <em>None (X11 Transport)</em> : equivalent to setting <code>VGL_COMPRESS=proxy</code>.
        This option can be activated at any time, regardless of which transport
        was active when VirtualGL started. <br /><br /> <em>JPEG (VGL Transport)</em>
        : equivalent to setting <code>VGL_COMPRESS=jpeg</code>.  This option
        is only available if the VGL Image Transport was active when the application
        started. <br /><br /> <em>RGB (VGL Transport)</em> : equivalent to
        setting <code>VGL_COMPRESS=rgb</code>.  This option is only available
        if the VGL Image Transport was active when the application started.
        <br /><br /> <em>DPCM (Sun Ray Transport)</em> : equivalent to setting
        <code>VGL_COMPRESS=sr</code>. This option is only available if the
        Sun Ray Image Transport was active when the application started.
        <br /><br /> <em>RGB (Sun Ray Transport)</em> : equivalent to setting
        <code>VGL_COMPRESS=srrgb</code>. This option is only available if the
        Sun Ray Image Transport was active when the application started.
        <br /><br /> See Section <a href="#VGL_COMPRESS" class="ref">19.1</a>
        for more information about the <code>VGL_COMPRESS</code> configuration
        option and its various parameters.
    </dd>
    <dt class="Description">Chrominance Subsampling</dt>
    <dd class="Description">
        This drop-down gadget is active only when using JPEG or Sun Ray DPCM
        compression.  It has the following options: <br /><br /> <em>Grayscale</em>
        : equivalent to setting <code>VGL_SUBSAMP=gray</code>.  Available only
        with JPEG compression. <br /><br /> <em>1X</em> : equivalent to setting
        <code>VGL_SUBSAMP=1x</code> <br /><br /> <em>2X</em> : equivalent to
        setting <code>VGL_SUBSAMP=2x</code> <br /><br /> <em>4X</em> : equivalent
        to setting <code>VGL_SUBSAMP=4x</code> <br /><br /> <em>8X</em> : equivalent
        to setting <code>VGL_SUBSAMP=8x</code>.  Available only with Sun Ray
        DPCM compression. <br /><br /> <em>16X</em> : equivalent to setting
        <code>VGL_SUBSAMP=16x</code>.  Available only with Sun Ray DPCM compression.
        <br /><br /> See Section <a href="#VGL_SUBSAMP" class="ref">19.1</a>
        for more information about the <code>VGL_SUBSAMP</code> configuration
        option and its various parameters.
    </dd>
    <dt class="Description">JPEG Image Quality</dt>
    <dd class="Description">
        This slider gadget is active only when using JPEG compression.  It
        is the equivalent of setting <code>VGL_QUAL</code>.  	See Section
        <a href="#VGL_QUAL" class="ref">19.1</a> for more information about
        the <code>VGL_QUAL</code> configuration option.
    </dd>
    <dt class="Description">Send Lossless Frame During Periods of Inactivity</dt>
    <dd class="Description">
        This toggle button is the equivalent of setting <code>VGL_PROGRESSIVE</code>.
        It is active only when using Sun Ray DPCM compression.  See Section
        <a href="#VGL_PROGRESSIVE" class="ref">19.1</a> for more information
        about the <code>VGL_PROGRESSIVE</code> configuration option.
    </dd>
    <dt class="Description">Connection Profile</dt>
    <dd class="Description">
        This drop-down gadget is active only if the VGL Image Transport was
        active when the application started.  It has the following options:
        <br /><br /> <em>Low Qual (Wide-Area Network)</em> : Sets the image
        compression type to JPEG (VGL Transport), sets the Chrominance Subsampling
        to 4X, and sets the JPEG Image Quality to 30. <br /><br /> <em>Medium
        Qual</em> : Sets the image compression type to JPEG	(VGL Transport),
        sets the Chrominance Subsampling to 2X, and sets the JPEG Image Quality
        to 80. <br /><br /> <em>High Qual (High-Speed Network)</em> : Sets
        the image compression type to JPEG (VGL Transport), sets the Chrominance
        Subsampling to 1X, and sets the JPEG Image Quality to 95.
    </dd>
    <dt class="Description">Gamma Correction Factor</dt>
    <dd class="Description">
        This floating point input gadget is the equivalent of setting <code>VGL_GAMMA</code>.
        If using a gamma-corrected visual (Sparc clients only), then this gadget
        has no effect.  Otherwise, it enables VirtualGL&rsquo;s internal gamma
        correction system with the specified gamma correction factor. See Section
        <a href="#VGL_GAMMA" class="ref">19.1</a> for more information about
        the <code>VGL_GAMMA</code> configuration option.
    </dd>
    <dt class="Description">Frame Spoiling</dt>
    <dd class="Description">
        This toggle button is the equivalent of setting <code>VGL_SPOIL</code>.
        See Section <a href="#Frame_Spoiling" class="ref">17.2</a> and Section
        <a href="#VGL_SPOIL" class="ref">19.1</a> for more information about
        the <code>VGL_SPOIL</code> configuration option.
    </dd>
    <dt class="Description">Interframe Comparison</dt>
    <dd class="Description">
        This toggle button is the equivalent of setting <code>VGL_INTERFRAME</code>.
        See Section <a href="#VGL_INTERFRAME" class="ref">19.1</a> for more
        information about the <code>VGL_INTERFRAME</code> configuration option.
    </dd>
    <dt class="Description">Stereographic Rendering Method</dt>
    <dd class="Description">
        This drop-down gadget has the following options: <br /><br /> <em>Send
        Left Eye Only</em> : equivalent to setting <code>VGL_STEREO=left</code>.
        <br /><br /> <em>Send Right Eye Only</em> : equivalent to setting <code>VGL_STEREO=right</code>
        <br /><br /> <em>Quad-Buffered (if available)</em> : equivalent to
        setting <code>VGL_STEREO=quad</code> <br /><br /> <em>Anaglyphic (Red/Cyan)</em>
        : equivalent to setting <code>VGL_STEREO=rc</code> <br /><br /> See
        Section <a href="#VGL_STEREO" class="ref">19.1</a> for more information
        about the <code>VGL_STEREO</code> configuration option and its various
        parameters.
    </dd>
    <dt class="Description">Limit Frames/second</dt>
    <dd class="Description">
        This floating point input gadget is the equivalent of setting <code>VGL_FPS</code>.
        See Section <a href="#VGL_FPS" class="ref">19.1</a> for more information
        about the <code>VGL_FPS</code> configuration option.
    </dd>
</dl>

<p>You can set the <code>VGL_GUI</code> environment variable to change
the key sequence used to pop up the VirtualGL Configuration dialog.
If the default of <code>CTRL-SHIFT-F9</code> is not suitable, then
set <code>VGL_GUI</code> to any combination of <code>ctrl</code>, <code>shift</code>,
<code>alt</code>, and one of <code>f1,&nbsp;f2,...,&nbsp;f12</code>
(these are not case sensitive.)  For example:</p>

<pre class="verbatim">
export&nbsp;VGL_GUI=CTRL-F9
</pre>

<p>will cause the dialog box to pop up whenever <code>CTRL-F9</code> is
pressed.</p>

<p>To disable the VirtualGL dialog altogether, set <code>VGL_GUI</code>
to <code>none</code>.</p>

<div class="important"><p class="important">
VirtualGL monitors the application&rsquo;s X event loop to determine whenever a particular key sequence has been pressed.  If an application is not monitoring key press events in its X event loop, then the VirtualGL configuration dialog might not pop up at all.  There is unfortunately no workaround for this, but it should be a rare occurrence.
</p></div>

<hr class="break" />


<h1 id="hd0019"><a name="file019"></a>19&nbsp;Advanced Configuration</h1>

<p><a name="Advanced_Configuration"></a></p>


<h2 id="hd0019001">19.1&nbsp;Server Settings</h2>

<p>You can control the operation of the VirtualGL faker in four different
ways. Each method of configuration takes precedence over the previous
method:</p>

<ol class="Ordered numeric">
    <li class="Ordered">
        Setting a configuration environment variable globally (for instance,
        in <code>/etc/profile</code>)
    </li>
    <li class="Ordered">
        Setting a configuration environment variable on a per-user basis (for
        instance, in <code>~/.bashrc</code>)
    </li>
    <li class="Ordered">
        Setting a configuration environment variable only for the current shell
        session (for instance, <code>export&nbsp;VGL_XXX={whatever}</code>)
    </li>
    <li class="Ordered">
        Passing a configuration option as an argument to <code>vglrun</code>.
        This effectively overrides any previous environment variable setting
        corresponding to that configuration option.
    </li>
</ol>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_CLIENT&nbsp;=&nbsp;</code><em><code>{c}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-cl&nbsp;</code><em><code>{c}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{c}</code></em> = the hostname or IP address of the VirtualGL client machine or Sun Ray server</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">Sun Ray, VGL</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Automatically set by <code>vglconnect</code> or <code>vglrun</code></td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        When using the VGL Image Transport, <code>VGL_CLIENT</code> should
        be set to the hostname or IP address of the machine on which <code>vglclient</code>
        is running.  When using the Sun Ray Image Transport, <code>VGL_CLIENT</code>
        should be set to the hostname or IP address of the Sun Ray server.
        Normally, <code>VGL_CLIENT</code> is set automatically by the <code>vglconnect</code>
        or <code>vglrun</code> script, so don&rsquo;t override it unless you
        know what you&rsquo;re doing.
    </dd>
</dl>

<p><a name="VGL_COMPRESS"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_COMPRESS&nbsp;=&nbsp;</code><em><code>proxy&nbsp;|&nbsp;jpeg&nbsp;|&nbsp;rgb&nbsp;|&nbsp;sr&nbsp;|&nbsp;srrgb</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-c&nbsp;</code><em><code>proxy&nbsp;|&nbsp;jpeg&nbsp;|&nbsp;rgb&nbsp;|&nbsp;sr&nbsp;|&nbsp;srrgb</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Set image transport and image compression type</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">(See description)</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
         <em>proxy</em> = Send images uncompressed using the X11 Image Transport.
         This is useful when displaying to a local X server or X proxy (see
         Section <a href="#TurboVNC_Usage_Local" class="ref">9.1</a>.)
         <br /><br /> <em>jpeg</em> = Compress images using JPEG and send using
         the VGL Image Transport. This is useful when displaying to a remote
         X server (see Chapter <a href="#VGL_Image_Transport_Usage" class="ref">8</a>.)
         <br /><br /> <em>rgb</em> = Encode images as uncompressed RGB and
         send using the VGL Image Transport.  This is useful when displaying
         to a remote X server or X proxy across a very fast network (see Section
         <a href="#TurboVNC_Usage_Remote" class="ref">9.2</a>.) <br /><br />
         <em>sr</em> = Compress images using the Sun Ray default compression
         method (DPCM) and send using the Sun Ray Image Transport.  This requires
         that the proprietary Sun Ray plugin be installed on the VirtualGL
         server. (see Chapter <a href="#Sun_Ray_Usage" class="ref">11</a>.)
         <br /><br /> <em>srrgb</em> = Encode images as uncompressed RGB and
         send using the Sun Ray Image Transport.  This requires that the proprietary
         Sun Ray plugin be installed on the VirtualGL server (see Chapter
         <a href="#Sun_Ray_Usage" class="ref">11</a>.) <br /><br /> If this
         option is not specified, then the default is set as follows:
         <br /><br /> If the X server is a Sun Ray server and the Sun Ray plugin
         is installed on the VirtualGL server, then VGL will default to using
         <em>sr</em> compression.  VGL will fall back to using <em>proxy</em>
         compression if, for any given frame, it is unable to send the frame
         using the Sun Ray Image Transport.  This could occur if, for example,
         the Sun Ray client is on a network that is not visible to the VirtualGL
         server. <br /><br /> If the X server is not a Sun Ray server but the
         <code>DISPLAY</code> environment variable begins with <code>:</code>
         or <code>unix:</code>, then VirtualGL assumes that the X display connection
         is local and it defaults to using <em>proxy</em> compression.  Otherwise,
         it defaults to <em>jpeg</em> compression.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_DISPLAY&nbsp;=&nbsp;</code><em><code>{d}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-d&nbsp;</code><em><code>{d}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{d}</code></em> = the X display or GLP device to use for 3D rendering</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">:0</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        If the VirtualGL server has multiple 3D graphics cards and you want
        the OpenGL rendering to be redirected to a display other than :0, then
        you can set <code>VGL_DISPLAY=:1.0</code> or whatever.  This could
        be used, for instance, to support many application instances on a beefy
        multi-pipe graphics server. <br /><br /> <em>GLP mode (Solaris/Sparc
        only):</em> <br /><br /> Setting this option to <code>glp</code> will
        enable GLP mode and use the first framebuffer device listed in <code>/etc/dt/config/GraphicsDevices</code>
        to perform 3D rendering.  You can also set this option to the pathname
        of a specific GLP device (example: <code>/dev/fbs/jfb0</code>.)  See
        Section <a href="#GLP_Usage" class="ref">6.1</a> for more details.
    </dd>
</dl>

<p><a name="VGL_FPS"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_FPS&nbsp;=&nbsp;</code><em><code>{f}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-fps&nbsp;</code><em><code>{f}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Limit the client/server frame rate to <em><code>{f}</code></em> frames/second, where <em><code>{f}</code></em> is a floating point number &gt; 0.0</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL, X11</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">No limit</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        This option prevents VirtualGL from sending frames at a rate faster
        than the specified limit.  It can be used, for instance, as a crude
        way to control network bandwidth or CPU usage in multi-user environments
        where those resources are constrained. <br /><br /> If frame spoiling
        is disabled, then this effectively limits the server&rsquo;s 3D rendering
        frame rate as well.
    </dd>
</dl>

<p><a name="VGL_GAMMA"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_GAMMA&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1&nbsp;|&nbsp;{g}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-g</code> / <code>+g</code> / <code>-gamma&nbsp;</code><em><code>{g}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable gamma correction and specify gamma correction factor</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard"><code>VGL_GAMMA=1</code> on Solaris/Sparc VGL servers, <code>VGL_GAMMA=0</code> otherwise</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        &ldquo;Gamma&rdquo; refers to the relationship between the intensity
        of light which your computer&rsquo;s monitor is instructed to display
        and the intensity which it actually displays.  The curve is an exponential
        curve of the form <em>Y = X<sup>G</sup></em>, where X is between 0
        and 1.  G is called the &ldquo;gamma&rdquo; of the monitor.  PC monitors
        and TV&rsquo;s usually have a gamma of around 2.2. <br /><br /> Some
        of the math involved in 3D rendering assumes a linear gamma (G = 1.0),
        so technically speaking, 3D applications will not display with mathematical
        correctness unless the pixels are &ldquo;gamma corrected&rdquo; to
        counterbalance the non-linear response curve of the monitor.  But some
        systems do not have any form of built-in gamma correction, and thus
        the applications developed for such systems have usually been designed
        to display properly without gamma correction.  Gamma correction involves
        passing pixels through a function of the form <em>X = W<sup>1/G</sup></em>,
        where G is the &ldquo;gamma correction factor&rdquo; and should be
        equal to the gamma of the monitor.  So the final output is <em>Y =
        X<sup>G</sup> = (W<sup>1/G</sup>)<sup>G</sup> = W</em>, which describes
        a linear relationship between the intensity of the pixels drawn by
        the application and the intensity of the pixels displayed by the monitor.
        <br /><br /> <em><code>VGL_GAMMA=1</code> or <code>vglrun&nbsp;+g</code>
        : Enable gamma correction with default settings</em> <br /><br /> This
        option tells VirtualGL to enable gamma correction using the best available
        method.  If VirtualGL is remotely displaying to a Solaris/Sparc X server
        which has gamma-corrected X visuals, then VGL will attempt to assign
        one of these visuals to the application.  This causes the 3D output
        of the application to be gamma corrected by the factor specified in
        <code>fbconfig</code> on the client machine (default: 2.22.)  Otherwise,
        if the X server does not have gamma-corrected X visuals or if the gamma-corrected
        visuals it has do not match the application&rsquo;s needs, then VirtualGL
        performs gamma correction internally and uses a default gamma correction
        factor of 2.22.  This option emulates the default behavior of OpenGL
        applications running locally on Sparc machines. <br /><br /> <em><code>VGL_GAMMA=0</code>
        or <code>vglrun&nbsp;-g</code> : Disable gamma correction</em>
        <br /><br /> This option tells VGL not to use gamma-corrected visuals,
        even if they are available on the X server, and disables VGL&rsquo;s
        internal gamma correction system as well.  This emulates the default
        behavior of OpenGL applications running locally on Linux or Solaris/x86
        machines. <br /><br /> <em><code>VGL_GAMMA=</code></em><code>{g}</code><em>
        or <code>vglrun&nbsp;-gamma&nbsp;</code></em><code>{g}</code><em> :
        Enable VGL&rsquo;s internal gamma correction system with a gamma correction
        factor of </em><code>{g}</code> <br /><br /> If <code>VGL_GAMMA</code>
        is set to an arbitrary floating point value, then VirtualGL performs
        gamma correction internally using the specified value as the gamma
        correction factor.  You can also specify a negative value to apply
        a &ldquo;de-gamma&rdquo; function.  Specifying a gamma correction factor
        of G (where G &lt; 0) is equivalent to specifying a gamma correction
        factor of -1/G.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_GLLIB&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{l}</code></em> = the location of an alternate OpenGL library</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        Normally, VirtualGL loads the first OpenGL dynamic library that it
        finds in the dynamic linker path (usually <code>/usr/lib/libGL.so.1</code>,
        <code>/usr/lib64/libGL.so.1</code>,  or <code>/usr/lib/64/libGL.so.1</code>.)
        You can use this setting to explicitly specify another OpenGL dynamic
        library to load. <br /><br /> You shouldn&rsquo;t need to muck with
        this unless something doesn&rsquo;t work.  However, this setting is
        necessary when using VirtualGL with
        <a href="#Chromium">Chromium</a><a name="idx0090"></a>.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_GUI&nbsp;=&nbsp;</code><em><code>{k}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{k}</code></em> = the key sequence used to pop up the VirtualGL Configuration dialog, or <code>none</code> to disable the dialog</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">shift-ctrl-f9</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        VirtualGL will normally monitor an application&rsquo;s X event queue
        and pop up the VirtualGL Configuration dialog whenever <code>CTRL-SHIFT-F9</code>
        is pressed.  In the event that this interferes with a key sequence
        that the application is already using, then you can redefine the key
        sequence used to pop up the VirtualGL Configuration dialog by setting
        <code>VGL_GUI</code> to some combination of <code>shift</code>, <code>ctrl</code>,
        <code>alt</code>, and one of <code>f1,&nbsp;f2,&nbsp;...,&nbsp;f12</code>.
        You can also set <code>VGL_GUI</code> to <code>none</code> to disable
        the configuration dialog altogether.  See Chapter
        <a href="#Config_Dialog" class="ref">18</a> for more details.
    </dd>
</dl>

<p><a name="VGL_INTERFRAME"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_INTERFRAME&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Enable or disable interframe image comparison</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">Sun Ray, VGL</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Enabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        The VGL and Sun Ray Image Transports will normally compare each frame
        with the previous frame and send only the portions of the image which
        have changed.  Setting <code>VGL_INTERFRAME</code> to <code>0</code>
        disables this behavior. <br /><br /> You shouldn&rsquo;t need to disable
        interframe comparison except in rare situations.  This setting was
        introduced in order to work around a specific interaction issue between
        VirtualGL and Pro/ENGINEER v3.  See Section
        <a href="#Application_Recipes" class="ref">15</a> for more information.
        <br /><br /> <em>When using the VGL Image Transport, interframe comparison
        is affected by the <code>VGL_TILESIZE</code> option</em>
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_LOG&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Redirect all messages from VirtualGL to a log file specified by <em><code>{l}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Print all messages to stderr</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        Setting this environment variable to the pathname of a log file on
        the VirtualGL server will cause VirtualGL to redirect all of its messages
        (including profiling and trace output) to the specified log file rather
        than to stderr.
    </dd>
</dl>

<p><a name="VGL_NPROCS"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_NPROCS&nbsp;=&nbsp;</code><em><code>{n}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-np&nbsp;</code><em><code>{n}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{n}</code></em> = the number of CPUs to use for multi-threaded compression</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">1</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        The VGL Image Transport can divide the task of compressing each frame
        among multiple server CPUs.  This might speed up the overall throughput
        in rare circumstances where the server CPUs are significantly slower
        than the client CPUs. <br /><br /> VirtualGL will not allow more than
        4 processors total to be used for compression, nor will it allow you
        to set this parameter to a value greater than the number of processors
        in the system. <br /><br /> <em>Multi-threaded compression is affected
        by the <code>VGL_TILESIZE</code> option</em>
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_PORT&nbsp;=&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-p&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{p}</code></em> = the TCP port to use when connecting to the VirtualGL Client</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Read from X property stored by VirtualGL Client</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        The connection port for the VGL Image Transport is normally determined
        by reading an X property that <code>vglclient</code> stores on the
        X server, so don&rsquo;t override this unless you know what you&rsquo;re
        doing.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_PROFILE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-pr</code> / <code>+pr</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable profiling output</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        If profiling output is enabled, then VirtualGL will continuously benchmark
        itself and periodically print out the throughput of various stages
        in its image pipelines. <br /><br /> See Chapter
        <a href="#Perf_Measurement" class="ref">17</a> for more details.
    </dd>
</dl>

<p><a name="VGL_PROGRESSIVE"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_PROGRESSIVE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-prog</code> / <code>+prog</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable sending a lossless (RGB) frame during periods of inactivity</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">Sun Ray (DPCM)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        When Sun Ray DPCM compression is being used, enabling this option causes
        the Sun Ray Image Transport to send a lossless (RGB) frame during periods
        of inactivity.  This is useful in environments where both image quality
        and performance are	critical.  With progressive mode enabled, the image
        quality for the Sun Ray compressor can be set to a fairly low value
        to speed up rotate/pan/zoom operations, then when the rotate/pan/zoom
        is completed, VirtualGL will send a lossless frame that can be analyzed
        by the user in more detail.
    </dd>
</dl>

<p><a name="VGL_QUAL"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_QUAL&nbsp;=&nbsp;</code><em><code>{q}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-q&nbsp;</code><em><code>{q}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{q}</code></em> = the JPEG compression quality, 1 &lt;= <em><code>{q}</code></em> &lt;= 100</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL (JPEG)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">95</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        In digital images, &ldquo;frequency&rdquo; refers to how quickly the
        color changes between light and dark as you move either horizontally
        or vertically in the image.  Images with very sharp, bright features
        on a dark background, for instance, consist of both low- and high-frequency
        components, whereas images with smooth transitions between neighboring
        pixels contain only low-frequency components.  JPEG compression works
        by breaking down the image into its constituent frequencies and then
        throwing out the highest of these frequencies.  The JPEG image &ldquo;quality&rdquo;
        determines which frequencies are thrown out.  A JPEG quality of 1 throws
        out all but the lowest frequencies and thus produces a very impressionistic,
        but generally not very useful, compressed image.  A JPEG quality of
        100 retains all frequencies in the original image (but, due to roundoff
        errors, is still not completely lossless.) <br /><br /> Because the
        human eye usually can&rsquo;t detect the highest frequencies in the
        image, and often because the image lacks those high-frequency elements
        to begin with, a sufficiently high JPEG quality setting can produce
        a &ldquo;perceptually lossless&rdquo; image.  A &ldquo;perceptually
        lossless&rdquo; image contains a small amount of mathematical error
        vs. the original image, but this error is so small that the human visual
        system cannot distinguish it (under normal circumstances.)  The threshold
        quality level at which JPEG compression becomes perceptually lossless
        is different for each image, but experiments with various visual difference
        benchmarks (such as
        <span class="remote"><a href="http://www.mpi-inf.mpg.de/resources/hdr/vdp/" class="remote">HDR-VDP</a></span><a name="idx0091"></a>)
        suggest that	a JPEG quality of 95 is sufficient to guarantee perceptual
        losslessness in the types of applications (volume visualization apps,
        in particular) where image quality is critical.  As with any benchmarks,
        Your Mileage May Vary.  If quality is of paramount concern, consider
        setting the JPEG quality to 100 or using RGB encoding.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_READBACK&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable VirtualGL&rsquo;s pixel pipelines</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Enabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        On rare occasions, it might be desirable to have VirtualGL redirect
        OpenGL rendering from an application into a Pbuffer but not automatically
        read back and send the rendered pixels.  Some applications have their
        own mechanisms for reading back the buffer, so setting <code>VGL_READBACK=0</code>
        disables VirtualGL&rsquo;s readback mechanism and prevents duplication
        of effort. <br /><br /> This feature was developed initially to support
        running
        <span class="remote"><a href="http://www.paraview.org/" class="remote">ParaView</a></span><a name="idx0092"></a>
        in parallel using MPI.  ParaView/MPI normally uses MPI processes 1
        through N as rendering servers, each drawing a portion of the geometry
        into a separate window on a separate X display. ParaView reads back
        these server windows and composites the pixels into the main application
        window, which is controlled by MPI process 0.  By creating a script
        which passes a different value of <code>VGL_DISPLAY</code> and <code>VGL_READBACK</code>
        to each MPI process, it is possible to make all of the ParaView server
        processes render to off-screen buffers on different graphics cards
        while preventing VirtualGL from displaying any pixels except those
        generated by process 0.
    </dd>
</dl>

<p><a name="VGL_SPOIL"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_SPOIL&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-sp</code> / <code>+sp</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable frame spoiling</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Enabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        By default, VirtualGL will drop frames so as not to slow down the rendering
        rate of the server&rsquo;s graphics engine.  This should produce the
        best results with interactive applications, but frame spoiling should
        be turned off when running benchmarks or other non-interactive applications.
        Turning off frame spoiling will force one frame to be sent to the client
        on every end-of-frame event, and thus the frame rate reported by OpenGL
        benchmarks will accurately reflect the frame rate of VirtualGL&rsquo;s
        image pipeline (though, in X proxy environments, this may still not
        accurately reflect the frame rate seen by the user.  See Section
        <a href="#Frame_Spoiling" class="ref">17.2</a>.)  Disabling frame spoiling
        also prevents non-interactive applications from wasting graphics resources
        by rendering frames that will never be seen.  With frame spoiling turned
        off, the 3D rendering pipeline behaves as if it is fill-rate limited
        to about 30 or 40 Megapixels/second, the maximum throughput of the
        VirtualGL system on current CPUs.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_SSL&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-s</code> / <code>+s</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable SSL encryption of the VGL Image Transport</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        Enabling this option causes the VGL Image Transport to be tunneled
        through a secure socket layer (SSL) (see Section
        <a href="#SSL_Encryption" class="ref">8.3</a>.)
    </dd>
</dl>

<p><a name="VGL_STEREO"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_STEREO&nbsp;=&nbsp;</code><em><code>left&nbsp;|&nbsp;right&nbsp;|&nbsp;quad&nbsp;|&nbsp;rc</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-st&nbsp;</code><em><code>left&nbsp;|&nbsp;right&nbsp;|&nbsp;quad&nbsp;|&nbsp;rc</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Specify the delivery method for stereo images</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">quad</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
         <em>left</em> = When an application renders a stereo frame, send only
         the left eye buffer <br /><br /> <em>right</em> = When an application
         renders a stereo frame, send only the right eye buffer <br /><br />
         <em>quad</em> = Attempt to use quad-buffered stereo, which will result
         in a pair of images being sent to the VirtualGL Client on every frame.
         If quad-buffered stereo is not available, either because the client
         or the image transport does not support it, then fall back to using
         anaglyphic stereo.  Quad-buffered stereo requires the VGL Image Transport,
         and it also requires that client support OpenGL and have a 3D accelerator
         that supports stereo rendering. <br /><br /> <em>rc</em> = Use Red/Cyan
         (anaglyphic) stereo, even if quad-buffered is available
         <br /><br /> See Chapter <a href="#Advanced_OpenGL" class="ref">16</a>
         for more details.
    </dd>
</dl>

<p><a name="VGL_SUBSAMP"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_SUBSAMP&nbsp;=&nbsp;</code><em><code>gray&nbsp;|&nbsp;1x&nbsp;|&nbsp;2x&nbsp;|&nbsp;4x&nbsp;|&nbsp;8x&nbsp;|&nbsp;16x</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-samp&nbsp;</code><em><code>gray&nbsp;|&nbsp;1x&nbsp;|&nbsp;2x&nbsp;|&nbsp;4x&nbsp;|&nbsp;8x&nbsp;|&nbsp;16x</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Specify the level of chrominance subsampling in the JPEG and Sun Ray image compressors</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">Sun Ray (DPCM), VGL (JPEG)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">1x for VGL Image Transport, 16x for Sun Ray Image Transport</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        When an image is compressed using JPEG or using Sun Ray DPCM compression,
        each pixel in the image is first converted from RGB (Red/Green/Blue)
        to YUV.  An RGB pixel has three values that specify the amounts of
        red, green, and blue that make up the pixel&rsquo;s color.  A YUV pixel
        has three values that specify the overall brightness of the pixel (Y,
        or &ldquo;luminance&rdquo;) and the overall color of the pixel (U and
        V, or &ldquo;chrominance&rdquo;.) <br /><br /> Since the human eye
        is less sensitive to changes in color than it is to changes in brightness,
        the chrominance components for some of the pixels can be discarded
        without much noticeable loss in image quality.  This technique, called
        &ldquo;chrominance subsampling&rdquo;, significantly reduces the size
        of the compressed image. <br /><br /> <em>1x</em> = no chrominance
        subsampling <br /><br /> <em>2x</em> = discard the chrominance components
        for every other pixel along the image&rsquo;s X direction (this is
        also known as &ldquo;4:2:2&rdquo; or &ldquo;2:1&rdquo; subsampling.)
        All else being equal, 2x subsampling generally reduces the image size
        by about 20-25% when compared to no subsampling.<br /> <br /> <em>4x</em>
        = discard the chrominance components for every other pixel along both
        the X and Y directions of the image (this is also known as &ldquo;4:2:0&rdquo;
        or &ldquo;2:2&rdquo; subsampling.)   All else being equal, 4x subsampling
        generally reduces the image size by about 35-40% when compared to no
        subsampling. <br /><br /> <em>8x</em> = discard the chrominance components
        for 3 out of every 4 pixels along the image&rsquo;s X direction and
        half the pixels along the image&rsquo;s Y direction (this is also known
        as &ldquo;4:1:0&rdquo; or &ldquo;4:2&rdquo; subsampling.)  <em>This
        option is available only with Sun Ray DPCM compression.</em>
        <br /><br /> <em>16x</em> = discard the chrominance components for
        3 out of every 4 pixels along both the X and Y directions of the image
        (this is also known as &ldquo;4:4&rdquo; subsampling.)  <em>This option
        is available only with Sun Ray DPCM compression.</em> <br /><br />
        <em>gray</em> = discard all chrominance components.  This is useful
        when running applications (such as medical visualization applications)
        that are already generating grayscale images.  <em>This option is available
        only with JPEG compression.</em> <br /><br /> Subsampling artifacts
        are less noticeable with volume data, since it usually only contains
        256 colors to begin with.  But narrow, aliased lines and other sharp
        features on a black background will tend to produce very noticeable
        artifacts when subsampling is enabled. <br /><br /> The Axis Indicator
        from a Popular Visualization App displayed with 1x, 2x, and 4x subsampling
        (respectively):<br />
        <img src="444.gif" alt="444" class="inline" id="imgid_10" name="imgid_10"/><img src="422.gif" alt="422" class="inline" id="imgid_11" name="imgid_11"/><img src="411.gif" alt="411" class="inline" id="imgid_12" name="imgid_12"/>
    </dd>
</dl>

<p><a name="VGL_SYNC"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_SYNC&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-sync</code> / <code>+sync</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable strict 2D/3D synchronization</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        Normally, VirtualGL&rsquo;s operation is asynchronous from the point
        of view of the application.  The application swaps the buffers or calls
        <code>glFinish()</code> or <code>glFlush()</code> or <code>glXWaitGL()</code>,
        and VirtualGL reads	back the framebuffer and sends the pixels to the
        client&rsquo;s display &hellip; eventually. This will work fine for
        the vast majority of applications, but it does not strictly conform
        to the GLX spec.  Technically speaking, when an application calls <code>glXWaitGL()</code>
        or <code>glFinish()</code>, it is well within its rights to expect
        the 3D image to be immediately available in the X window. Fortunately,
        very few applications actually do expect this, but on rare occasions,
        an application may try to use <code>XGetImage()</code> or other X11
        functions to obtain a bitmap of the pixels that were rendered by OpenGL.
        Enabling <code>VGL_SYNC</code> is a somewhat extreme measure that may
        be needed to make such applications work properly.  It was developed
        initially as a way to pass the GLX conformance suite (<code>conformx</code>,
        specifically), but at least one commercial application is known to
        require it as well (see <a href="#Application_Recipes">Application
        Recipes</a><a name="idx0093"></a>.)<br /><br />When <code>VGL_SYNC</code>
        is enabled, every call to <code>glFinish()</code>, <code>glXWaitGL()</code>,
        and <code>glXSwapBuffers()</code> will cause the contents of the server&rsquo;s
        framebuffer to be read back and <em>synchronously</em> drawn into the
        application&rsquo;s window <em>using the X11 Image Transport and no
        frame spoiling</em>.  The call to <code>glFinish()</code>, <code>glXWaitGL()</code>,
        or <code>glXSwapBuffers()</code> will not return until VirtualGL has
        verified that the pixels have been delivered into the application&rsquo;s
        window.  As such, this mode can have potentially dire effects on performance
        when used with a remote X server.  It is thus strongly recommended
        that <code>VGL_SYNC</code> be used only in conjunction with an X proxy
        (such as TurboVNC) running on the same server as VirtualGL.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_TILESIZE&nbsp;=&nbsp;</code><em><code>{t}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{t}</code></em> = the image tile size (<em><code>{t}</code></em> x <em><code>{t}</code></em> pixels) to use for multi-threaded compression and interframe comparison (8 &lt;= <em><code>{t}</code></em> &lt;= 1024)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">256</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        Normally, the VGL Image Transport will divide an OpenGL window into
        equal-sized square tiles, compare each tile vs. the same tile in the
        previous frame, and compress &amp; send only the tiles which have changed
        (assuming interframe comparison is enabled.)  The VGL Image Transport
        will also divide up the task of compressing these tiles among the available
        CPUs in a round robin fashion, if multi-threaded compression is enabled
        (see <a href="#VGL_NPROCS">VGL_NPROCS</a><a name="idx0094"></a>.)
        <br /><br /> There are several tradeoffs that must be considered when
        choosing a tile size: <br /><br /> <em>Smaller tile sizes:</em>
        <ul class="Itemize"><li>
            Better parallel scalability
        </li>
        <li>
            Worse compression efficiency
        </li>
        <li>
            Better inter-frame optimization
        </li>
        <li>
            Worse network efficiency
        </li></ul> <em>Larger tile sizes:</em> <ul class="Itemize"><li>
            Worse parallel scalability
        </li>
        <li>
            Better compression efficiency
        </li>
        <li>
            Worse inter-frame optimization
        </li>
        <li>
            Better network efficiency
        </li></ul> <br /> Smaller tiles can more easily be divided up among
        multiple CPUs, but they compress less efficiently (and less quickly)
        on an individual basis.  Using larger tiles can reduce traffic to the
        client by allowing the server to send only one frame update instead
        of many.  But on the flip side, using larger tiles decreases the chance
        that a tile will be unchanged from the previous frame. <br /><br />
        256x256 was chosen as the default because, in experiments, it provided
        the best balance between scalability and efficiency on the platforms
        that VirtualGL supports.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_TRACE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-tr</code> / <code>+tr</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable tracing</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        When tracing is enabled, VirtualGL will log all calls to the GLX and
        X11 functions it is intercepting, as well as the arguments, return
        values, and execution times for those functions.  This is useful when
        diagnosing interaction problems between VirtualGL and a particular
        OpenGL application.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_VERBOSE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-v</code> / <code>+v</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable verbose VirtualGL messages</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        When in verbose mode, VirtualGL will reveal some of the decisions it
        makes behind the scenes, such as which code path it is using to compress
        images, which type of X11 drawing it is using, etc.  This can be helpful
        when diagnosing performance problems.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_X11LIB&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{l}</code></em> = the location of an alternate X11 library</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        Normally, VirtualGL loads the first X11 dynamic library that it finds
        in the dynamic linker path (usually <code>/usr/lib/libX11.so.?</code>,
        <code>/usr/lib/64/libX11.so.?</code>, <code>/usr/X11R6/lib/libX11.so.?</code>,
        or <code>/usr/X11R6/lib64/libX11.so.?</code>.)  You can use this setting
        to explicitly specify another X11 dynamic library to load.
        <br /><br /> You shouldn&rsquo;t need to muck with this unless something
        doesn&rsquo;t work.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_XVENDOR&nbsp;=&nbsp;</code><em><code>{v}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{v}</code></em> = a fake X11 vendor string to return when the application calls <code>XServerVendor()</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        Some applications expect <code>XServerVendor()</code> to return a particular
        value, which the application (sometimes erroneously) uses to figure
        out whether it&rsquo;s running locally or remotely.  This setting allows
        you to fool such applications into thinking they&rsquo;re running on
        a &ldquo;local&rdquo; X server rather than a remote connection.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_ZOOM_X&nbsp;=&nbsp;</code><em><code>1&nbsp;|&nbsp;2</code></em><br /> <code>VGL_ZOOM_Y&nbsp;=&nbsp;</code><em><code>1&nbsp;|&nbsp;2</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Subsample all pixels by the specified factor</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">Sun Ray</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">1</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        Setting <code>VGL_ZOOM_X=2</code> causes the Sun Ray Image Transport
        to discard every other pixel along the X direction of the image.  Setting
        <code>VGL_ZOOM_Y=2</code> does the same thing for the Y direction of
        the image.  This differs from <code>VGL_SUBSAMP</code> in that <code>VGL_SUBSAMP</code>
        discards only luminance components from the pixels it subsamples. 
        <code>VGL_ZOOM_*</code>, on the other hand, discards the entire pixels.
        The result is extremely grainy, so this option is generally only useful
        in conjunction with <code>VGL_PROGRESSIVE</code>.
    </dd>
</dl>


<h2 id="hd0019002">19.2&nbsp;Client Settings</h2>

<p>These settings control the VirtualGL Client, which is used only with
the VGL Image Transport.  <code>vglclient</code> is normally launched
automatically from <code>vglconnect</code> and should not require any
further configuration except in exotic circumstances.  These settings
are meant only for advanced users or those wishing to build additional
infrastructure around VirtualGL.</p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGLCLIENT_DRAWMODE&nbsp;=&nbsp;</code><em><code>ogl&nbsp;|&nbsp;x11</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglclient</code> argument</td>
    <td class="standard"><code>-gl</code> / <code>-x</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Specify the method used to draw pixels into the application window</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard"><code>ogl</code> for Solaris/Sparc systems with 3D accelerators, <code>x11</code> otherwise</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        If the client machine has a 3D accelerator, then it may be faster to
        draw pixels using OpenGL than using 2D (X11) commands.  This is particularly
        true of many 3D accelerators available for the Sparc platform, since
        they are able to draw images using 24-bit pixels instead of the 32-bit
        pixels required by the X server.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGLCLIENT_LISTEN&nbsp;=&nbsp;</code><em><code>sslonly&nbsp;|&nbsp;nossl</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglclient</code> argument</td>
    <td class="standard"><code>-sslonly</code> / <code>-nossl</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Accept only unencrypted or only SSL connections from the VirtualGL server</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Accept both SSL and unencrypted connections</td>
  </tr>
</table>
</div>


<p><br /></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGLCLIENT_PORT&nbsp;=&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglclient</code> argument</td>
    <td class="standard"><code>-port&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{p}</code></em> = TCP port on which to listen for unencrypted connections from the VirtualGL server</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Automatically select a free port</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        The default behavior for <code>vglclient</code> is to first try listening
        on port	4242, to maintain backward compatibility with VirtualGL v2.0.x.
        If port 4242 is not available, then <code>vglclient</code> will try
        to find a free port in the range of 4200-4299.  If none of those ports
        is available, then <code>vglclient</code> will request a free port
        from the operating system. <br /><br /> Passing this argument to <code>vglclient</code>
        circumvents the automatic behavior described above and causes <code>vglclient</code>
        to listen only on the specified TCP port.  Don&rsquo;t do this unless
        you know what you&rsquo;re doing.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_PROFILE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable profiling output</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        If profiling output is enabled, then VirtualGL will continuously benchmark
        itself and periodically print out the throughput of various stages
        in its image pipelines. <br /><br /> See Chapter
        <a href="#Perf_Measurement" class="ref">17</a> for more details.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGLCLIENT_SSLPORT&nbsp;=&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglclient</code> argument</td>
    <td class="standard"><code>-sslport&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{p}</code></em> = TCP port on which to listen for SSL connections from the VirtualGL server</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Automatically select a free port</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        The default behavior for <code>vglclient</code> is to first try listening
        on port	4243, to maintain backward compatibility with VirtualGL v2.0.x.
        If port 4243 is not available, then <code>vglclient</code> will try
        to find a free port in the range of 4200-4299.  If none of those ports
        is available, then <code>vglclient</code> will request a free port
        from the operating system. <br /><br /> Passing this argument to <code>vglclient</code>
        circumvents the automatic behavior described above and causes <code>vglclient</code>
        to listen only on the specified TCP port.  Don&rsquo;t do this unless
        you know what you&rsquo;re doing.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_VERBOSE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable verbose VirtualGL messages</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description">Description</dt>
    <dd class="Description">
        When in verbose mode, VirtualGL will reveal some of the decisions it
        makes behind the scenes, such as which code path it is using to decompress
        images, which type of X11 drawing it is using, etc.  This can be helpful
        when diagnosing performance problems.
    </dd>
</dl>

</body>
</html>

